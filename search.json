[{"title":"Taro 中使用 Vuex & 数据持久化存储","url":"/2022/01/10/taro-vuex/","content":"前言许久没有关注小程序的生态圈发展，这两天发现在造轮子这一块，各大厂商都玩的天花乱坠。最近打算开始试试由京东开发的 Taro，记录一下上手体验以及遇到的一些小问题。\n是什么官方说明：\n\nTaro 是一个开放式跨端跨框架解决方案，支持使用 React/Vue/Nerv 等框架来开发 微信 / 京东 / 百度 / 支付宝 / 字节跳动 / QQ / 飞书 小程序 / H5 / RN 等应用。\n\n简言之，Taro 旨在：只编写一套代码，就能够多端运行。\n上手具体流程可参考官方文档：Taro\n数据状态管理 (Vuex)由于我选择的是 Vue 来开发，所以状态管理选择的是 Vuex.\n\n安装 vuex\nyarn add vuex\n项目集成\n\n新建 src/store/index.js\n\n  import Vue from \"vue\";\nimport Vuex from \"vuex\";\nVue.use(Vuex);\nexport default new Vuex.Store(&#123;\n  state: &#123;\n    userinfo: &#123;\n      nickname: \"zhangsan\"\n    &#125;\n  &#125;,\n  mutations: &#123;&#125;\n&#125;);\n\napp.js 中引入 store\n\n  // 部分代码\nimport store from './store';\n\nconst App = &#123;\n  store,\n  render(h) &#123;\n    return h('block', this.$slots.default)\n  &#125;\n&#125;\n\nexport default App\n\n至此发现，和 Vue 的开发也没什么区别\n数据持久化存储选用 vuex-persistedstate\n\n安装\nyarn add vuex-persistedstate\n项目集成\n\n改造 src/store/index.js\n\n  import Vue from \"vue\";\nimport Vuex from \"vuex\";\nimport persistedState from \"vuex-persistedstate\";\nVue.use(Vuex);\nexport default new Vuex.Store(&#123;\n  state: &#123;\n    userinfo: &#123;\n      nickname: \"zhangsan\"\n    &#125;\n  &#125;,\n  mutations: &#123;\n    testChangeNickname: (state, payload) => &#123;\n      state.userinfo.nickname = payload.nickname\n    &#125;\n  &#125;,\n  plugins: [\n    persistedState()\n  ]\n&#125;);\n\n\n在 state 中特别加入 userinfo: &#123; nickname: &#39;zhangsan&#39; &#125;, mutations 中加入 testChangeNickname 来测试调用。\n编译发现很尴尬，报错了。\nsetItem of undefined\n看起来是 persistedState 的 storage 默认使用的是 window 所导致的，而小程序里肯定不能直接调用 window.\n\n再改 src/store/index.js\n\n  // 部分代码\nimport Taro from '@tarojs/taro'\nplugins: [\n  persistedState(&#123;\n    storage: &#123;\n      getItem: key => &#123;\n        return Taro.getStorageSync(key)\n      &#125;,\n      setItem: (key, value) => &#123;\n        Taro.setStorageSync(key, value)\n      &#125;,\n      removeItem: key => &#123;\n        Taro.removeStorageSync(key)\n      &#125;\n    &#125;\n  &#125;)\n]\n  \n将 getItem、setItem、removeItem 全部改成 Taro 调用\n编译正常。\n\n\n\n业务测试\n\n获取 state\n\ncomputed: &#123;\n  nickname() &#123;\n    return this.$store.state.userinfo.nickname\n  &#125;\n&#125;,\n\n\n触发 mutations\n\nthis.$store.commit('testChangeNickname', &#123; nickname: 'lisi' &#125;)\n\n结语至此，完成 Taro 中使用 Vuex &amp; 数据持久化存储。\n持续采坑中…\n","categories":["技术分享"],"tags":["小程序","Taro"]},{"title":"自己写一个掘金自动签到的脚本","url":"/2021/11/29/auto-juejin/","content":"前言1024 的时候我发现掘金的福利兑换礼品真的是白菜价，奈何如此少的矿石，我依然没有。我每天开始去签到，只是为了来年 1024 的时候去挥霍一番，可是我发现每天都念叨这件事情属实让我很不舒服，因为只有女朋友可以让我每天如此思念 T_T\n所以我决定写个自动签到的脚本来帮我干这件事情 (:\n功能点自动签到聪明的人打开浏览器控制台就可以找到签到对应的接口:\n\n查询今日是否已经签到：\n\nhttps://api.juejin.cn/growth_api/v1/get_today_status\n\n\n签到：\n\nhttps://api.juejin.cn/growth_api/v1/check_in\n\n这样一来就非常简单了，先获取一下签到状态，没签到的去签个到：\n// 查询今日是否已经签到\nconst getTodayCheckStatus = async () => &#123;\n  const cookie = '从浏览器的请求头里 copy 一个 cookie';\n  let &#123; data &#125; = await axios(&#123;\n    url: 'https://api.juejin.cn/growth_api/v1/get_today_status',\n    method: \"get\",\n    headers: &#123;\n      Cookie: cookie,\n    &#125;,\n  &#125;);\n  return &#123;\n    error: data.err_no !== 0,\n    isCheck: data.data,\n  &#125;;\n&#125;;\n\n// 签到\nconst checkIn = async () => &#123;\n  let &#123; error, isCheck &#125; = await getTodayCheckStatus();\n  if (error) &#123;\n    console.log('验证签到错误');\n    return;\n  &#125;\n  if (isCheck) &#123;\n    console.log('已经签到');\n    return;\n  &#125;\n  const cookie = '从浏览器的请求头里 copy 一个 cookie';\n  let &#123; data &#125; = await axios(&#123;\n    url: 'https://api.juejin.cn/growth_api/v1/check_in',\n    method: \"post\",\n    headers: &#123;\n      Cookie: cookie,\n    &#125;,\n  &#125;);\n  if (data.err_no) &#123;\n    console.log('签到失败');\n  &#125; else &#123;\n    console.log('签到成功');\n  &#125;\n&#125;;\n\n顺带免费抽奖聪明的人又打开了浏览器的控制台找到了抽奖对应的接口:\n\n获取抽奖配置：\n\nhttps://api.juejin.cn/growth_api/v1/lottery_config/get\n\n\n发起抽奖\n\nhttps://api.juejin.cn/growth_api/v1/lottery/draw\n\n这样一来就又非常简单了，先获取一下抽奖状态，没抽奖的去抽个奖：\nconst getTodayLotteryStatus = async () => &#123;\n  const cookie = '从浏览器的请求头里 copy 一个 cookie';\n  let &#123; data &#125; = await axios(&#123;\n    url: 'https://api.juejin.cn/growth_api/v1/lottery_config/get',\n    method: \"get\",\n    headers: &#123;\n      Cookie: cookie,\n    &#125;,\n  &#125;);\n  if (data.err_no) &#123;\n    return &#123;\n      error: true,\n      isLotteryed: false,\n    &#125;;\n  &#125; else &#123;\n    return &#123;\n      error: false,\n      isLotteryed: data.data.free_count === 0,\n    &#125;;\n  &#125;\n&#125;;\n\n// 抽奖\nconst draw = async () => &#123;\n  let &#123; error, isLotteryed &#125; = await getTodayLotteryStatus();\n  if (error || isLotteryed) &#123;\n    console.log('抽过啦');\n    return;\n  &#125; \n  const cookie = '从浏览器的请求头里 copy 一个 cookie';\n  let &#123; data &#125; = await axios(&#123;\n    url: 'https://api.juejin.cn/growth_api/v1/lottery/draw',\n    method: \"post\",\n    headers: &#123;\n      Cookie: cookie,\n    &#125;,\n  &#125;);\n  if (data.err_no) &#123;\n    console.log('抽奖失败啦');\n    return;\n  &#125;\n  console.log('抽奖结果:\\n' + data);\n&#125;;\n\n失败了再顺带给我发个邮件邮件服务可以参考：nodemailer\nconst sendEmail = async (subject, html) => &#123;\n  // xxx\n&#125;;\n\n将上面函数里失败的 console.log() 替换成邮件提醒 await sendEmail()\n丢到服务器上每天定时执行let job = new Cron(\n  \"10 10 10 * * *\",\n  async () => &#123;\n    await checkIn();\n    await draw();\n  &#125;,\n  null,\n  true,\n  'Asia/Shanghai'\n);\n\njob.start();\n\n注意事项由于 cookie 会过期，所以失败之后可以尝试在浏览器里重新 copy 一个 cookie 到脚本里执行。\n","categories":["技术分享"],"tags":["Web","BackEnd"]},{"title":"珍品收藏links","url":"/2021/11/18/favorite-links/","content":"珍品收藏dev开发常见：\n\ntinypng\n\nbase64图片在线转换工具\n\nUU在线工具\n\ni Hate Regex - The Regex Cheat Sheet\n\nRGB颜色值与十六进制颜色码转换工具\n\nAn image cache &amp; resize service.\n\nNavicat for MySQL 15注册激活\n\n插图-Illustrations | unDraw\n\n插图-404 Illustrations\n\nError 404 png\n\nCarbon | Create and share beautiful images of your source code\n\nAnimista - CSS Animations on Demand\n\n表情速查\n\npublic APIs\n\n\ndaily生活类：\n\n违法不良信息举报中心\n\nGenerate a Random Name - Fake Name Generator\n\n免费短信接收-有信云短信\n\nTemp Mail - 临时性 - 匿名电子邮件\n\n消除图片中的背景 – remove.bg\n\nsquoosh-图片压缩\n\nthis person does not exist\n\n手写思维导图\n\n\n","categories":[],"tags":[]},{"title":"【图片压缩二】使用node批量压缩图片","url":"/2021/10/22/image-node/","content":"前言相比于一些APP或者在线网站，有时候我们的业务工程里需要集成压缩图片的功能，node环境下，imagemin 就非常适合做这件事情。\n概述imagemin是一种插件模式的压缩工具，需要根据所需压缩图片的格式来按需加载对应的插件。\nnpm install imagemin\nnpm install imagemin-jpegtran // OR imagemin-mozjpeg\nnpm install imagemin-pngquant\nnpm install imagemin-svgo\nnpm install imagemin-imagemin-webp\n\n使用方法\n压缩目录images下的图片文件，输出文件到目录下：\n\nimport imagemin from 'imagemin';\nimport imageminMozjpeg  from 'imagemin-mozjpeg';\nimport imageminPngquant from 'imagemin-pngquant';\n\n(async () => &#123;\n  const files = await imagemin(['images/*.&#123;jpg,png&#125;'], &#123;\n    destination: 'build',\n    plugins: [\n      imageminMozjpeg(&#123;\n        quality: 50,\n      &#125;),\n      imageminPngquant(&#123;\n        quality: [0.5, 0.8]\n      &#125;)\n    ]\n  &#125;);\n  console.log(files);\n&#125;)();\n\n\n修改成函数式：传入图片的base64，输出压缩后的base64\n\nimport imagemin from 'imagemin';\nimport imageminMozjpeg  from 'imagemin-mozjpeg';\nimport imageminPngquant from 'imagemin-pngquant';\n\n(async () => &#123;\n  const base64Str = '';\n  const ogBuffer = Buffer.from(base64Str, \"base64\");\n\n  const files = await imagemin.buffer(ogBuffer, &#123;\n    plugins: [\n      imageminMozjpeg(&#123;\n        quality: 50,\n      &#125;),\n      imageminPngquant(&#123;\n        quality: [0.5, 0.8]\n      &#125;)\n    ]\n  &#125;);\n\n  console.log(files.toString('base64'));\n\n&#125;)();\n","categories":["小轮子"],"tags":["node","图片"]},{"title":"根据 IP 限制访问接口的频率","url":"/2021/10/20/ratelimit/","content":"前言业务上线之后，经常会出现一些来路不明的人在持续不断的请求业务接口，这些请求就算没有产生数据安全问题也会对业务服务器产生一些压力，那么如何拦截这些请求就成了一个不得不去面对的问题。解决方案有很多种，其中之一就是：根据 IP 限制访问接口的频率\n设计思路以10秒钟之内请求次数不超过20次为例\n\n把请求的 ip 和接口路由 path 拼接起来作为 key，把请求的次数作为 value，存进Redis，并设置过期时间为10秒\n\n第一次请求设置 value 为1，以后每次请求 value + 1\n\n每一次请求都重置过期时间，并且判断 value 是否大于 10\n\n如果没过期，且 value 大于 10，则是应该被限制的请求\n\n\n伪代码以 eggjs/midway 中间件为例\n\nconst cacheName = `$&#123;ip&#125;-$&#123;path&#125;`; // key\n\nconst ttl = await redisService.ttl(cacheName); // key是否有剩余时间\n\nif (ttl > 0) &#123;\n  const count = await redisService.read(cacheName); // key已经请求的次数\n  if (count &amp;&amp; +count &lt; 20) &#123;\n    // 如果还没到20次，次数加1，重置过期时间，正确返回\n    await redisService.write(cacheName, count + 1, ttl);\n    await next();\n  &#125; else &#123;\n    // 次数大于阈值，拦截，返回429\n    throw Error('too many requests', 429);\n  &#125;\n&#125; else &#123;\n   // ttl &lt; 0, 重新写\n  await redisService.write(cacheName, 1, 10);\n  await next();\n&#125;\n","categories":["技术分享"],"tags":["BackEnd","node"]},{"title":"【图片压缩一】Python结合TinyPNG批量压缩图片","url":"/2021/10/19/image-tinypng-py/","content":"前言在使用TinyPng压缩图片的时候经常会遇到需要一次性压缩很多张，网站使用起来需要本地选择图片然后上传再下载压缩之后的图片，很不方便，所以想搞一个脚本在本地运行可以递归压缩文件夹及子文件夹中的所有图片。\n准备工作安装一下tinify\npip install --upgrade tinify\n\n核心科技import tinify\nimport os\nimport os.path\n\ntinify.key =\"XXXXXXXX\" # AppKey--tinypng申请的key\nfromPath =\"/Users/xxx/Desktop/temp-test/pic-test/source\" # source path\ntoPath =\"/Users/xxx/Desktop/temp-test/pic-test/dest\" # dest path\n\nfor root, dirs, files in os.walk(fromPath):\n newToPath = toPath\n if len(root) > len(fromPath):\n  innerPath= root[len(fromPath):]\n  if innerPath[0] == '/':\n   innerPath = innerPath[1:]\n  newToPath =  os.path.join(toPath,innerPath)\n\n for name in files:\n  newFromFilePath = os.path.join(root, name)\n  newToFilePath = os.path.join(newToPath, name)  \n  fileName, fileSuffix = os.path.splitext(name)\n  if fileSuffix == '.png' or fileSuffix == '.jpg':\n   source = tinify.from_file(newFromFilePath)\n   source.to_file(newToFilePath)\n  else:\n   pass\n\n for dirName in dirs:\n  os.mkdir(os.path.join(newToPath, dirName))\n\n","categories":["小轮子"],"tags":["图片","Python"]},{"title":"我不希望别人可以随意调试我的网站代码","url":"/2021/08/28/browser-debugger/","content":"起因在某次爬虫（科学获取网站资讯数据）的时候，我打开了该网站的控制台，通过Network 和Sources 两个Tab选项，我发现很容易就调试出了它的接口请求参数，当时就整个一洋洋得意。但是我转念一想，如果是我自己的网站，我不希望别人也可以这样轻而易举地调试我的页面，我应该怎么防止呢？\n预防手段在开发过程中，我们通常会在页面上打很多断点用来调试，我突发奇想，如果有人打开页面的控制台，我让他一直处于debugger当中，这样不就让他没法进行下一步了吗？\n这个简单，几行代码的事情\n(() => &#123;\n  setInterval(() => &#123;\n    debugger;\n  &#125;, 100);\n&#125;)();\n\n这段代码的作用是：通过一直处于debugger状态来阻塞你程序的执行，没办法在Source Tab中对js进行加断点，没办法继续调试程序的执行逻辑。但是Sources Tab选项中，我们可以添加Ignore List来过滤掉我们加的debugger\n这样设置，页面中的debugger就不生效了…\n但是，只要思想不滑坡，困难总比方法多\n(() => &#123;\n  setInterval(() => &#123;\n    Function(\"debugger\")();\n  &#125;, 100);\n&#125;)();\n\nFunction生成的debugger会在每一次执行的时候都开启一个临时的js文件，而你的Ignore List只能遇到一次加一次，永远落后我的脚步&#x1F61B;\n说干就干既然这样，我不如直接写个webpack插件，给每个.js文件都加上这段话，岂不是美滋滋~\n核心代码：\nconst &#123; ConcatSource &#125; = require('webpack-sources')\n\nclass AddDbugJs &#123;\n  constructor () &#123;&#125;\n\n  apply (compiler) &#123;\n    compiler.hooks.afterCompile.tapAsync(&#123;\n      name: 'AddDbugJs',\n    &#125;, (compilation, callback) => &#123;\n      let assetNames = Object.keys(compilation.assets)\n      for (const name of assetNames) &#123;\n        if (name.endsWith('.js')) &#123;\n          let dbug = `setInterval(() => &#123;(function () &#123;return false;&#125;[\"constructor\"](\"debugger\")[\"call\"]());&#125;, 100);`\n          compilation.updateAsset(\n            name,\n            old => new ConcatSource(old, '\\n', dbug),\n          )\n        &#125;\n      &#125;\n      callback()\n    &#125;)\n  &#125;\n&#125;\n\nmodule.exports = AddDbugJs\n\n\n在项目中使用它：\nconst AddDbugJs = require('add-dbug-js')\nmodule.exports = &#123;\n  devServer: &#123;&#125;,\n  configureWebpack: &#123;\n    plugins:\n      process.env.NODE_ENV !== 'production'\n        ? []\n        : [new AddDbugJs()],\n  &#125;,\n&#125;\n\n这就成了 &#x1F973;\n","categories":["技术分享"],"tags":["Web"]},{"title":"反爬虫机制和破解方法汇总","url":"/2021/08/25/crawl-tips/","content":"说明网络不是法外之地，请大家文明上网\n\n反爬虫机制\n通过UA 识别爬虫有些爬虫的UA很好识别，比如百度，与正常浏览器的UA是不一样的，可以通过识别UA的方法直接封禁此类请求\n\n设置IP的访问频率如果同一个IP超过一定频率，可以通过弹出验证码的方式来过滤机器人（如何巧妙设置验证，也是一个很有意思的问题）\n\n通过并发识别爬虫很多爬虫的并发率是非常高的，当达到一定阈值，可以直接封禁\n\n限制单个 IP/API token的访问量\n\n识别出合法爬虫设置合法爬虫的白名单，例如百度的自动收录等，如果不是合法爬虫则可以直接封禁\n\n蜜罐资源蜜罐资源策略简单来说就是 钓鱼执法 ，通过在页面上设置一些隐式链接，普通用户无法访问，一旦有IP请求了这些资源，则可以判断这些IP是爬虫的IP\n\n\n破解反爬虫机制\n设置下载延迟\n\n禁止cookie很多网站会通过cookie识别用户身份，禁止cookie可以让服务器无法追踪爬虫轨迹\n\n使用UA池每次发送爬虫请求的时候，从UA池里随机使用一个UA\n\n使用IP池每次发送爬虫请求的时候，使用不同的代理IP\n\n分布式爬取\n\n模拟登录\n\n\n","categories":["技术分享"],"tags":["爬虫"]},{"title":"使用Steam作为第三方账号登录你的网站","url":"/2021/08/22/steam/","content":"前言  在日常网络冲浪中，很多网站要求我们注册登录的时候，我们都可以选择使用 QQ|微信|微博|Github 等作为第三方账号去登录。那么如果我的网站都是游戏相关的内容，我可不可以让用户 使用 Steam 作为第三方账号登录 呢？\n问题分析基于网页浏览器的 OpenID 验证如 OpenID 2.0（了解更多） 规范所描述，Steam 只是一个 OpenID 的提供者。在网页浏览器内，第三方网站可以使用 OpenID 来获取用户的 SteamID ，用户的 SteamID 可以用来作为第三方网站的登录凭据（登录）或者与第三方网站的既有账户绑定（注册）。\n流程描述当用户希望登录第三方网站并且将自己的账号与 Steam 账号绑定，第三方网站将用户重定向到 Steam 社区的登录授权页面，用户输入 Steam 的登录凭证后，浏览器自动重定向回第三方网站，并将一些额外的 OpenID 数据写入返回的 URL 中。这些数据通过验证之后即可解析出用户的 SteamID 。\n具体操作申请一个用来校验信息的 ApiKey到这里申请 =&gt; steamcommunity\n构造用来登录的链接参数说明：\nsteamLoginUrl: https://steamcommunity.com/openid/login\nreturnUrl: Steam社区登录之后重定向的链接，一般为登录之后的网站首页 https://xxx.com\nrealm: steam社区授权页面显示的第三方网站名称\n\n// 返回的链接\nconst url = `$&#123;steamLoginUrl&#125;?openid.ns=http://specs.openid.net/auth/2.0&amp;openid.mode=checkid_setup&amp;openid.return_to=$&#123;returnUrl&#125;&amp;openid.realm=$&#123;realm&#125;&amp;openid.identity=http://specs.openid.net/auth/2.0/identifier_select&amp;openid.claimed_id=http://specs.openid.net/auth/2.0/identifier_select`;\n\n当用户点击网页上的 Steam 登录标识的时候，浏览器将用户重定向到 url ，在用户授权之后，会回到 returnUrl 页面。\n校验Steam返回的数据当 Steam 成功授权登录返回到我们的 returnUrl 页面之后，页面链接中会带有很多额外信息：\nconst respUrl = `$&#123;returnUrl&#125;?openid.ns=http://specs.openid.net/auth/2.0&amp;openid.mode=id_res&amp;openid.op_endpoint=https://steamcommunity.com/openid/login&amp;openid.claimed_id=https://steamcommunity.com/openid/id/xxxxxxxxxxx&amp;openid.identity=https://steamcommunity.com/openid/id/xxxxxxxxxxx&amp;openid.return_to=https:/%mywebsite.com&amp;openid.response_nonce=2020-08-27T04:44:16Zs4DPZce8qc+iPCe8JgQKB0BiIDI=&amp;openid.assoc_handle=1234567890&amp;openid.signed=signed,op_endpoint,claimed_id,identity,return_to,response_nonce,assoc_handle&amp;openid.sig=W0u5DRbtHE1GG0ZKXjerUZDUGmc=`;\n\n\n具体的参数说明可参考steam官方文档\n因为返回的参数中带有用户的 SteamID 字段，为了保证信息安全，我们需要对数据进行正确性校验。定义 params = respUrl ? 后面的内容\n\n替换 params 中的 openid.mode=id_res 为 openid.mode=check_authentication\n\n构造校验链接\n const validateUrl = `https://steamcommunity.com/openid/login?$&#123;params&#125;`;\n通过 GET 请求 validateUrl 得到校验结果 得到一个 text/plain 类型的response：\n ns:http://specs.openid.net/auth/2.0\nis_valid:true\n\n is_valid:true 表明校验通过。\n\n\n通过用户的SteamID来获取用户的个人信息当校验完用户的 Steam 登录之后，我们便可以在返回的数据中获取到用户的 SteamID 。\n`openid.identity=https://steamcommunity.com/openid/id/xxxxxxxxxxx(此处则是用户的SteamID)`\n\n通过 Steam 平台开放接口，我们则可以获取到用户的 Steam 个人信息。\nGET 请求：\n  `https://api.steampowered.com/ISteamUser/GetPlayerSummaries/v2/?key=$&#123;开篇申请的ApiKey&#125;&amp;steamids=$&#123;用户的SteamID&#125;`\n\n返回的数据格式：\n\"response\":&#123;  \n  \"players\":[  \n     &#123;  \n        \"steamid\":\"xxxxxxxxxxx\",\n        \"communityvisibilitystate\":1,\n        \"profilestate\":1,\n        \"personaname\":\"xxxx\",\n        \"lastlogoff\":1556305001,\n        \"profileurl\":\"https://steamcommunity.com/profiles/xxxxxxxxxxx/\",\n        \"avatar\":\"https://steamcdn-a.akamaihd.net/steamcommunity/public/images/avatars/32/xxxxxxxxxxx.jpg\",\n        \"avatarmedium\":\"https://steamcdn-a.akamaihd.net/steamcommunity/public/images/avatars/32/xxxxxxxxxxx.jpg\",\n        \"avatarfull\":\"https://steamcdn-a.akamaihd.net/steamcommunity/public/images/avatars/32/xxxxxxxxxxx.jpg\",\n     &#125;\n  ]\n&#125;\n\n至此，使用 Steam 作为网站的第三方账号登录并且获取用户的 Steam 信息就已经全部完成。\n结语 &amp; 一些小问题\n为保证数据安全性，ApiKey 应该存储在网站自己的服务器上，所有的构造链接以及校验过程都应该放在后端完成。\n\nSteam 社区登录的时候偶尔可能需要用户科学上网，一旦用户不能正常访问 Steam 的登录功能，页面要做好容错处理。\n\n\n","categories":["技术分享"],"tags":["Web","BackEnd","Steam"]},{"title":"音乐格式转换","url":"/2021/08/19/music/","content":"为什么需要我们常见的音乐格式很多，但是很多时候由于我们的一些特殊需要，必须将音乐转换成mp3格式才可以被使用。本文只是从技术的角度将ncm格式转换成mp3格式。\n注意事项请勿用作商业用途\n\n源代码# -*- coding: utf-8 -*-\nimport binascii\nimport struct\nimport base64\nimport json\nimport os\nfrom Crypto.Cipher import AES\n\ndef dump(file_path):\n    core_key = binascii.a2b_hex(\"687A4852416D736F356B496E62617857\")\n    meta_key = binascii.a2b_hex(\"2331346C6A6B5F215C5D2630553C2728\")\n    unpad = lambda s : s[0:-(s[-1] if type(s[-1]) == int else ord(s[-1]))]\n    f = open(file_path,'rb')\n    header = f.read(8)\n    assert binascii.b2a_hex(header) == b'4354454e4644414d'\n    f.seek(2, 1)\n    key_length = f.read(4)\n    key_length = struct.unpack('&lt;I', bytes(key_length))[0]\n    key_data = f.read(key_length)\n    key_data_array = bytearray(key_data)\n    for i in range (0,len(key_data_array)): key_data_array[i] ^= 0x64\n    key_data = bytes(key_data_array)\n    cryptor = AES.new(core_key, AES.MODE_ECB)\n    key_data = unpad(cryptor.decrypt(key_data))[17:]\n    key_length = len(key_data)\n    key_data = bytearray(key_data)\n    key_box = bytearray(range(256))\n    c = 0\n    last_byte = 0\n    key_offset = 0\n    for i in range(256):\n        swap = key_box[i]\n        c = (swap + last_byte + key_data[key_offset]) &amp; 0xff\n        key_offset += 1\n        if key_offset >= key_length: key_offset = 0\n        key_box[i] = key_box[c]\n        key_box[c] = swap\n        last_byte = c\n    meta_length = f.read(4)\n    meta_length = struct.unpack('&lt;I', bytes(meta_length))[0]\n    meta_data = f.read(meta_length)\n    meta_data_array = bytearray(meta_data)\n    for i in range(0,len(meta_data_array)): meta_data_array[i] ^= 0x63\n    meta_data = bytes(meta_data_array)\n    meta_data = base64.b64decode(meta_data[22:])\n    cryptor = AES.new(meta_key, AES.MODE_ECB)\n    meta_data = unpad(cryptor.decrypt(meta_data)).decode('utf-8')[6:]\n    meta_data = json.loads(meta_data)\n    crc32 = f.read(4)\n    crc32 = struct.unpack('&lt;I', bytes(crc32))[0]\n    f.seek(5, 1)\n    image_size = f.read(4)\n    image_size = struct.unpack('&lt;I', bytes(image_size))[0]\n    image_data = f.read(image_size)\n    file_name = meta_data['musicName'] + '.' + meta_data['format']\n    m = open(os.path.join(os.path.split(file_path)[0],file_name),'wb')\n    chunk = bytearray()\n    while True:\n        chunk = bytearray(f.read(0x8000))\n        chunk_length = len(chunk)\n        if not chunk:\n            break\n        for i in range(1,chunk_length+1):\n            j = i &amp; 0xff;\n            chunk[i-1] ^= key_box[(key_box[j] + key_box[(key_box[j] + j) &amp; 0xff]) &amp; 0xff]\n        m.write(chunk)\n    m.close()\n    f.close()\n\ndef file_name(file_dir):\n    for root, dirs, files in os.walk(file_dir):\n        for file in files:\n            if os.path.splitext(file)[1] == '.ncm':\n                dump(file)\n                print(file)\n\nif __name__ == '__main__':\n    import sys\n    try:\n        print(os.getcwd())\n        file_name(os.getcwd())\n    except:\n        print('fail')\n\n\n运行方式将music.py与ncm格式的音乐文件放在同一个目录下\npython music.py\n","categories":["小轮子"],"tags":["Python","音乐"]},{"title":"Hello World","url":"/2021/08/18/hello-world/","content":"关于我又开始写博客这件事起因大约两个月前，我加入了一个很有活力的创业团队。这两个月里，我作为一面的面试官参与了几次招聘，并且工作模式也从原来的瀑布式开发转成了敏捷式开发。在这个过程中，我愈发意识到良好的语言表达能力在日常生活与工作中的重要性。因此我决定开始通过写文章的方式来提升自己的语言组织能力与表述能力。\n大概会写些什么内容\n日常工作遇到的一些问题，包括但不限于：前端：Vue、Nuxt、js/ts、CSS、Webpack等后端：Node爬虫：Node、Python数据库：MySQL、TypeORM等\n\n一些阅读积累，包括但不限于： 技术型书籍阅读笔记 文学性书籍读后感\n\n造一些小轮子\n\n\n","categories":[],"tags":[]},{"title":"404","url":"/404","content":"\n\n\n  \n  [居家呆猫]-404\n  \n\n\n  \n    .container {\n      width: 100%;\n      height: 100%;\n      position: fixed;\n      top: 0;\n      left: 0;\n      display: flex;\n      flex-direction: column;\n      justify-content: flex-start;\n      align-items: center;\n    }\n    .notfind {\n      width: 80%;\n      height: 80%\n    }\n    .back {\n      margin-top: 20px;\n      font-size: 16px;\n      text-decoration:none;\n      color: #fb7299;\n    }\n  \n  \n    \n     (゜-゜)つロ返回首页\n  \n\n\n","categories":[],"tags":[]},{"title":"About Maria","url":"/about/","content":"who\n&#x1F5A5;&nbsp;&nbsp;喜欢尝试的 「瞎折腾」 工程师\n&#x1F43E;&nbsp;&nbsp;比较喜欢喝三得利无糖乌龙茶\n\nskills\n以前写了很久的前端\n也写一些爬虫\n移动端 | 小程序也可以写一写\n最近开始写后端\n……\n\nlikes\n音乐：摇滚、后朋、金属\n阅读：加缪、里尔克、余华、赫尔曼黑塞、卡尔维诺、博尔赫斯\n电影：希区柯克、库布里克、侯麦、贾樟柯、杨德昌\n技术相关：尤大、轮子哥vczh、TK教主\n\n最近在听的歌 \n","categories":[],"tags":[]}]