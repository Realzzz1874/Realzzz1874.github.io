[{"title":"我不希望别人可以随意调试我的网站代码","url":"/2021/08/28/browser-debugger/","content":"起因在某次爬虫（科学获取网站资讯数据）的时候，我打开了该网站的控制台，通过Network 和Sources 两个Tab选项，我发现很容易就调试出了它的接口请求参数，当时就整个一洋洋得意。但是我转念一想，如果是我自己的网站，我不希望别人也可以这样轻而易举地调试我的页面，我应该怎么防止呢？\n预防手段在开发过程中，我们通常会在页面上打很多断点用来调试，我突发奇想，如果有人打开页面的控制台，我让他一直处于debugger当中，这样不就让他没法进行下一步了吗？\n这个简单，几行代码的事情\n(() => &#123;\n  setInterval(() => &#123;\n    debugger;\n  &#125;, 100);\n&#125;)();\n\n这段代码的作用是：通过一直处于debugger状态来阻塞你程序的执行，没办法在Source Tab中对js进行加断点，没办法继续调试程序的执行逻辑。但是Sources Tab选项中，我们可以添加Ignore List来过滤掉我们加的debugger\n这样设置，页面中的debugger就不生效了…\n但是，只要思想不滑坡，困难总比方法多\n(() => &#123;\n  setInterval(() => &#123;\n    Function(\"debugger\")();\n  &#125;, 100);\n&#125;)();\n\nFunction生成的debugger会在每一次执行的时候都开启一个临时的js文件，而你的Ignore List只能遇到一次加一次，永远落后我的脚步&#x1F61B;\n说干就干既然这样，我不如直接写个webpack插件，给每个.js文件都加上这段话，岂不是美滋滋~\n核心代码：\nconst &#123; ConcatSource &#125; = require('webpack-sources')\n\nclass AddDbugJs &#123;\n  constructor () &#123;&#125;\n\n  apply (compiler) &#123;\n    compiler.hooks.afterCompile.tapAsync(&#123;\n      name: 'AddDbugJs',\n    &#125;, (compilation, callback) => &#123;\n      let assetNames = Object.keys(compilation.assets)\n      for (const name of assetNames) &#123;\n        if (name.endsWith('.js')) &#123;\n          let dbug = `setInterval(() => &#123;(function () &#123;return false;&#125;[\"constructor\"](\"debugger\")[\"call\"]());&#125;, 100);`\n          compilation.updateAsset(\n            name,\n            old => new ConcatSource(old, '\\n', dbug),\n          )\n        &#125;\n      &#125;\n      callback()\n    &#125;)\n  &#125;\n&#125;\n\nmodule.exports = AddDbugJs\n\n\n在项目中使用它：\nconst AddDbugJs = require('add-dbug-js')\nmodule.exports = &#123;\n  devServer: &#123;&#125;,\n  configureWebpack: &#123;\n    plugins:\n      process.env.NODE_ENV !== 'production'\n        ? []\n        : [new AddDbugJs()],\n  &#125;,\n&#125;\n\n这就成了 &#x1F973;\n","categories":["技术分享"],"tags":["Web"]},{"title":"反爬虫机制和破解方法汇总","url":"/2021/08/25/crawl-tips/","content":"说明网络不是法外之地，请大家文明上网\n\n反爬虫机制\n通过UA 识别爬虫有些爬虫的UA很好识别，比如百度，与正常浏览器的UA是不一样的，可以通过识别UA的方法直接封禁此类请求\n\n设置IP的访问频率如果同一个IP超过一定频率，可以通过弹出验证码的方式来过滤机器人（如何巧妙设置验证，也是一个很有意思的问题）\n\n通过并发识别爬虫很多爬虫的并发率是非常高的，当达到一定阈值，可以直接封禁\n\n限制单个 IP/API token的访问量\n\n识别出合法爬虫设置合法爬虫的白名单，例如百度的自动收录等，如果不是合法爬虫则可以直接封禁\n\n蜜罐资源蜜罐资源策略简单来说就是 钓鱼执法 ，通过在页面上设置一些隐式链接，普通用户无法访问，一旦有IP请求了这些资源，则可以判断这些IP是爬虫的IP\n\n\n破解反爬虫机制\n设置下载延迟\n\n禁止cookie很多网站会通过cookie识别用户身份，禁止cookie可以让服务器无法追踪爬虫轨迹\n\n使用UA池每次发送爬虫请求的时候，从UA池里随机使用一个UA\n\n使用IP池每次发送爬虫请求的时候，使用不同的代理IP\n\n分布式爬取\n\n模拟登录\n\n\n","categories":["技术分享"],"tags":["爬虫"]},{"title":"使用Steam作为第三方账号登录你的网站","url":"/2021/08/22/steam/","content":"前言  在日常网络冲浪中，很多网站要求我们注册登录的时候，我们都可以选择使用 QQ|微信|微博|Github 等作为第三方账号去登录。那么如果我的网站都是游戏相关的内容，我可不可以让用户 使用 Steam 作为第三方账号登录 呢？\n问题分析基于网页浏览器的 OpenID 验证如 OpenID 2.0（了解更多） 规范所描述，Steam 只是一个 OpenID 的提供者。在网页浏览器内，第三方网站可以使用 OpenID 来获取用户的 SteamID ，用户的 SteamID 可以用来作为第三方网站的登录凭据（登录）或者与第三方网站的既有账户绑定（注册）。\n流程描述当用户希望登录第三方网站并且将自己的账号与 Steam 账号绑定，第三方网站将用户重定向到 Steam 社区的登录授权页面，用户输入 Steam 的登录凭证后，浏览器自动重定向回第三方网站，并将一些额外的 OpenID 数据写入返回的 URL 中。这些数据通过验证之后即可解析出用户的 SteamID 。\n具体操作申请一个用来校验信息的 ApiKey到这里申请 =&gt; steamcommunity\n构造用来登录的链接参数说明：\nsteamLoginUrl: https://steamcommunity.com/openid/login\nreturnUrl: Steam社区登录之后重定向的链接，一般为登录之后的网站首页 https://xxx.com\nrealm: steam社区授权页面显示的第三方网站名称\n\n// 返回的链接\nconst url = `$&#123;steamLoginUrl&#125;?openid.ns=http://specs.openid.net/auth/2.0&amp;openid.mode=checkid_setup&amp;openid.return_to=$&#123;returnUrl&#125;&amp;openid.realm=$&#123;realm&#125;&amp;openid.identity=http://specs.openid.net/auth/2.0/identifier_select&amp;openid.claimed_id=http://specs.openid.net/auth/2.0/identifier_select`;\n\n当用户点击网页上的 Steam 登录标识的时候，浏览器将用户重定向到 url ，在用户授权之后，会回到 returnUrl 页面。\n校验Steam返回的数据当 Steam 成功授权登录返回到我们的 returnUrl 页面之后，页面链接中会带有很多额外信息：\nconst respUrl = `$&#123;returnUrl&#125;?openid.ns=http://specs.openid.net/auth/2.0&amp;openid.mode=id_res&amp;openid.op_endpoint=https://steamcommunity.com/openid/login&amp;openid.claimed_id=https://steamcommunity.com/openid/id/xxxxxxxxxxx&amp;openid.identity=https://steamcommunity.com/openid/id/xxxxxxxxxxx&amp;openid.return_to=https:/%mywebsite.com&amp;openid.response_nonce=2020-08-27T04:44:16Zs4DPZce8qc+iPCe8JgQKB0BiIDI=&amp;openid.assoc_handle=1234567890&amp;openid.signed=signed,op_endpoint,claimed_id,identity,return_to,response_nonce,assoc_handle&amp;openid.sig=W0u5DRbtHE1GG0ZKXjerUZDUGmc=`;\n\n\n具体的参数说明可参考steam官方文档\n因为返回的参数中带有用户的 SteamID 字段，为了保证信息安全，我们需要对数据进行正确性校验。定义 params = respUrl ? 后面的内容\n\n替换 params 中的 openid.mode=id_res 为 openid.mode=check_authentication\n\n构造校验链接\n const validateUrl = `https://steamcommunity.com/openid/login?$&#123;params&#125;`;\n通过 GET 请求 validateUrl 得到校验结果 得到一个 text/plain 类型的response：\n ns:http://specs.openid.net/auth/2.0\nis_valid:true\n\n is_valid:true 表明校验通过。\n\n\n通过用户的SteamID来获取用户的个人信息当校验完用户的 Steam 登录之后，我们便可以在返回的数据中获取到用户的 SteamID 。\n`openid.identity=https://steamcommunity.com/openid/id/xxxxxxxxxxx(此处则是用户的SteamID)`\n\n通过 Steam 平台开放接口，我们则可以获取到用户的 Steam 个人信息。\nGET 请求：\n  `https://api.steampowered.com/ISteamUser/GetPlayerSummaries/v2/?key=$&#123;开篇申请的ApiKey&#125;&amp;steamids=$&#123;用户的SteamID&#125;`\n\n返回的数据格式：\n\"response\":&#123;  \n  \"players\":[  \n     &#123;  \n        \"steamid\":\"xxxxxxxxxxx\",\n        \"communityvisibilitystate\":1,\n        \"profilestate\":1,\n        \"personaname\":\"xxxx\",\n        \"lastlogoff\":1556305001,\n        \"profileurl\":\"https://steamcommunity.com/profiles/xxxxxxxxxxx/\",\n        \"avatar\":\"https://steamcdn-a.akamaihd.net/steamcommunity/public/images/avatars/32/xxxxxxxxxxx.jpg\",\n        \"avatarmedium\":\"https://steamcdn-a.akamaihd.net/steamcommunity/public/images/avatars/32/xxxxxxxxxxx.jpg\",\n        \"avatarfull\":\"https://steamcdn-a.akamaihd.net/steamcommunity/public/images/avatars/32/xxxxxxxxxxx.jpg\",\n     &#125;\n  ]\n&#125;\n\n至此，使用 Steam 作为网站的第三方账号登录并且获取用户的 Steam 信息就已经全部完成。\n结语 &amp; 一些小问题\n为保证数据安全性，ApiKey 应该存储在网站自己的服务器上，所有的构造链接以及校验过程都应该放在后端完成。\n\nSteam 社区登录的时候偶尔可能需要用户科学上网，一旦用户不能正常访问 Steam 的登录功能，页面要做好容错处理。\n\n\n","categories":["技术分享"],"tags":["Web","Steam","BackEnd"]},{"title":"音乐格式转换","url":"/2021/08/19/music/","content":"为什么需要我们常见的音乐格式很多，但是很多时候由于我们的一些特殊需要，必须将音乐转换成mp3格式才可以被使用。本文只是从技术的角度将ncm格式转换成mp3格式。\n注意事项请勿用作商业用途\n\n源代码# -*- coding: utf-8 -*-\nimport binascii\nimport struct\nimport base64\nimport json\nimport os\nfrom Crypto.Cipher import AES\n\ndef dump(file_path):\n    core_key = binascii.a2b_hex(\"687A4852416D736F356B496E62617857\")\n    meta_key = binascii.a2b_hex(\"2331346C6A6B5F215C5D2630553C2728\")\n    unpad = lambda s : s[0:-(s[-1] if type(s[-1]) == int else ord(s[-1]))]\n    f = open(file_path,'rb')\n    header = f.read(8)\n    assert binascii.b2a_hex(header) == b'4354454e4644414d'\n    f.seek(2, 1)\n    key_length = f.read(4)\n    key_length = struct.unpack('&lt;I', bytes(key_length))[0]\n    key_data = f.read(key_length)\n    key_data_array = bytearray(key_data)\n    for i in range (0,len(key_data_array)): key_data_array[i] ^= 0x64\n    key_data = bytes(key_data_array)\n    cryptor = AES.new(core_key, AES.MODE_ECB)\n    key_data = unpad(cryptor.decrypt(key_data))[17:]\n    key_length = len(key_data)\n    key_data = bytearray(key_data)\n    key_box = bytearray(range(256))\n    c = 0\n    last_byte = 0\n    key_offset = 0\n    for i in range(256):\n        swap = key_box[i]\n        c = (swap + last_byte + key_data[key_offset]) &amp; 0xff\n        key_offset += 1\n        if key_offset >= key_length: key_offset = 0\n        key_box[i] = key_box[c]\n        key_box[c] = swap\n        last_byte = c\n    meta_length = f.read(4)\n    meta_length = struct.unpack('&lt;I', bytes(meta_length))[0]\n    meta_data = f.read(meta_length)\n    meta_data_array = bytearray(meta_data)\n    for i in range(0,len(meta_data_array)): meta_data_array[i] ^= 0x63\n    meta_data = bytes(meta_data_array)\n    meta_data = base64.b64decode(meta_data[22:])\n    cryptor = AES.new(meta_key, AES.MODE_ECB)\n    meta_data = unpad(cryptor.decrypt(meta_data)).decode('utf-8')[6:]\n    meta_data = json.loads(meta_data)\n    crc32 = f.read(4)\n    crc32 = struct.unpack('&lt;I', bytes(crc32))[0]\n    f.seek(5, 1)\n    image_size = f.read(4)\n    image_size = struct.unpack('&lt;I', bytes(image_size))[0]\n    image_data = f.read(image_size)\n    file_name = meta_data['musicName'] + '.' + meta_data['format']\n    m = open(os.path.join(os.path.split(file_path)[0],file_name),'wb')\n    chunk = bytearray()\n    while True:\n        chunk = bytearray(f.read(0x8000))\n        chunk_length = len(chunk)\n        if not chunk:\n            break\n        for i in range(1,chunk_length+1):\n            j = i &amp; 0xff;\n            chunk[i-1] ^= key_box[(key_box[j] + key_box[(key_box[j] + j) &amp; 0xff]) &amp; 0xff]\n        m.write(chunk)\n    m.close()\n    f.close()\n\ndef file_name(file_dir):\n    for root, dirs, files in os.walk(file_dir):\n        for file in files:\n            if os.path.splitext(file)[1] == '.ncm':\n                dump(file)\n                print(file)\n\nif __name__ == '__main__':\n    import sys\n    try:\n        print(os.getcwd())\n        file_name(os.getcwd())\n    except:\n        print('fail')\n\n\n运行方式将music.py与ncm格式的音乐文件放在同一个目录下\npython music.py\n","categories":["小轮子"],"tags":["Python","音乐"]},{"title":"Hello World","url":"/2021/08/18/hello-world/","content":"关于我又开始写博客这件事起因大约两个月前，我加入了一个很有活力的创业团队。这两个月里，我作为一面的面试官参与了几次招聘，并且工作模式也从原来的瀑布式开发转成了敏捷式开发。在这个过程中，我愈发意识到良好的语言表达能力在日常生活与工作中的重要性。因此我决定开始通过写文章的方式来提升自己的语言组织能力与表述能力。\n大概会写些什么内容\n日常工作遇到的一些问题，包括但不限于：前端：Vue、Nuxt、js/ts、CSS、Webpack等后端：Node爬虫：Node、Python数据库：MySQL、TypeORM等\n\n一些阅读积累，包括但不限于： 技术型书籍阅读笔记 文学性书籍读后感\n\n造一些小轮子\n\n\n","categories":[],"tags":[]}]