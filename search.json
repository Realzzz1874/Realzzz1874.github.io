[{"title":"用 setTimeout 模拟 setInterval","url":"/2022/05/15/settimeout/","content":"前言\n为什么要用 setTimeout 模拟 setInterval 呢？\n\n在 JavaScript 事件循环过程中，setInterval 是一个宏任务，它的定义是：按照指定的周期（以毫秒计）来调用函数或计算表达式。\n然而我们永久了会发现，很多时候，它并不会按照我们的期望来 work。\n问题点推入任务队列后的时间不准确\nsetInterval 用法：setInterval(fn(), N);表示：fn() 将会在 N 秒之后被推入任务队列。所以，在 setInterval 被推入任务队列时，如果它前面有很多任务或者某个任务等待的时间比较长，那么这个定时器的执行时间就会和我们预定它执行的时间并不一致。\n多个定时器连续执行某些间隔会被跳过setTimeoutsetInterval 指定的时间间隔，表示的是何时将定时器的代码添加到消息队列中，而不是何时执行代码。所以真正何时执行代码的时间是不能保证的，取决于何时被主线程的事件循环取出并执行。\n\n上图可见:\n\nsetInterval 每隔 100ms 往队列中添加一个事件；\n100ms 后，添加 T1 定时器代码至队列中，主线程中还有任务在执行，所以等待，some event 执行结束后执行 T1 定时器代码；\n又过了 100ms，T2 定时器被添加到队列中，主线程还在执行 T1 代码，所以等待；\n又过了 100ms，理论上又要往队列里推一个定时器代码，但由于此时 T2 还在队列中，所以 T3 不会被添加（T3 被跳过），结果就是此时被跳过；\n这里我们可以看到，T1 定时器执行结束后马上执行了 T2 代码，所以并没有达到定时器的效果。\n\n每个 setTimeout 产生的任务会直接 push 到任务队列中；而 setInterval 在每次把任务 push 到任务队列前，都要进行一下判断(看上次的任务是否仍在队列中，如果有则不添加，没有则添加)。\nsetTimeout 模拟 setInterval\n在前一个定时器执行完前，不会向队列插入新的定时器\n保证定时器间隔\n\n\n定义 interval 方法\nlet timer = null;\ninterval(func, wait) &#123;\n    let interv = function()&#123;\n        func.call(null);\n        timer=setTimeout(interv, wait);\n    &#125;;\n    timer= setTimeout(interv, wait);\n &#125;\n和 setInterval() 一样使用它\ninterval(function() &#123;&#125;, 20);\n终止定时器\nif (timer) &#123;\n  window.clearSetTimeout(timer);\n  timer = null;\n&#125;\n\n结束","categories":["技术分享"],"tags":["Web","JS"]},{"title":"ssh manager 写个脚本来管理我的 ssh server","url":"/2022/05/06/ssh-manager/","content":"前言每次想登录一台吃灰的服务器的时候，都要想半天 host + password（找各种备忘录），于是乎想写一个小脚本来管理它们，虽然通过编辑 /.ssh/config 文件也可以实现类似功能，但是每次添加或者查看都还是需要去 cd xxx &amp; vim xxx，作为 新脚本小子，肯定得更 优雅 一点才行。\n内容github: ssh-manager\n#!/bin/bash\ncommand=$1\npath=~/.ssh/sshm/\nadd()&#123;\n    read -r -p \"server name:\" server_name\n    read -r -p \"server host:\" server_host\n    read -r -p \"server port(22):\" server_port\n    read -r -p \"server user(root):\" server_user\n    read -r -p \"server password:\" server_password\n\n    if [[ -z \"$server_name\" || -z \"$server_host\" ]]\n    then\n    \techo \"server_name or server_host does not exist\"\n    \texit;\n    fi\n\n    server_port=$&#123;server_port:-22&#125;\n    server_user=$&#123;server_user:-\"root\"&#125;\n\n\tif [ ! -d $path ]\n\tthen\n\t\t( mkdir $path )\n\tfi\n\n\tif [ ! -f $path$server_name ]\n\tthen\n\t\t( touch $path$server_name )\n\telse\n\n\t\tread -r -p \"server_name [$server_name] already exists, overwrite [o] or enter new server_name: \" action\n\t\tif [ ! $action ]\n\t\tthen\n\t\t\texit\n\t\tfi\n\n\t\tif [ $action == \"o\" ]\n\t\tthen\n\t\t\techo \"\" > $path$server_name\n\t\telse\n\t\t\tif [ $server_name == $action ]\n\t\t\tthen\n\t\t\t\techo \"server_name already exists!\"\n\t\t\t\texit\n\t\t\telse\n\t\t\t\tserver_name=$action\n\t\t\tfi\n\t\tfi\n\n\tfi\n\n    echo \"server_name=$server_name\" >> $path$server_name\n    echo \"server_host=$server_host\" >> $path$server_name\n    echo \"server_port=$server_port\" >> $path$server_name\n    echo \"server_user=$server_user\" >> $path$server_name\n    echo \"server_password=$server_password\" >> $path$server_name\n&#125;\n\nls()&#123;\n\tfor file in $path*\n\tdo\n\t\twhile read line\n\t\tdo\n\t\t    eval \"$line\"\n\t\tdone &lt; $file\n\t    echo \"`basename $file`: $server_host\"\n\t    unset server_host\n\tdone\n&#125;\n\nlogin()&#123;\n\tif [ ! -f $path$1 ]\n\tthen\n\t\techo \"server_name [$1] does not exist\"\n\t\texit\n\tfi\n\twhile read line\n\tdo\n\t    eval \"$line\"\n\tdone &lt; $path$1\n\texpect -c'\n\tspawn ssh -p '$server_port' '$server_user'@'$server_host'\n\texpect &#123;\n\t\t\"*yes/no\" &#123; send \"yes\\r\"; exp_continue&#125;\n\t\t\"*assword:\" &#123; send \"'$server_password'\\r\" &#125;\n\t&#125;\n\tinteract\n\t'\n&#125;\n\ndelete()&#123;\n\tread -r -p \"do you want to delete [y] ?\" action\n\tif [ \"$action\"x == \"y\"x ]\n\tthen\n\t\trm -rf $path$1\n\tfi\n\texit\n&#125;\n\ncase $command in\n  (add)\n     add\n     ;;\n  (ls)\n     ls\n     ;;\n  (rm)\n     delete $2\n     ;;\n  (*)\n     login $command\n     ;;\nesac\n\n用法chmod +x ./sshm.sh\n\nglobal usecp sshm.sh /usr/local/bin/sshm\n# use just like:\nsshp ls\n\naddsshm add\n\nlistsshm ls\n\nlogin serversshm server_name\n\ndeletesshm rm server_name\n\n结束","categories":["小轮子"],"tags":["shell"]},{"title":"一份工作中最重要的 5 个要素","url":"/2022/05/05/work-think/","content":"一份工作中最重要的 5 个要素\n同事是怎么样的\n老板是怎么样的\n工作空间的舒适程度\n报酬\n每天实际上在做的事情\n\n对于当前的工作，这五条中有多少觉得满意呢？\n","categories":["软件开发随想录"],"tags":[]},{"title":"工作中如何高效沟通","url":"/2022/04/08/communication/","content":"","categories":["软件开发随想录"],"tags":["项目管理"]},{"title":"【耳朵会说话-01】《硬汉》 - 腰乐队","url":"/2022/03/26/music-01/","content":"\n\n作词 : 刘涛\n作曲 : 杨绍昆\n吉他：杨绍昆 洪宇\n贝斯：胡尚洪\n鼓：艾永彬\n\n调查显示国人较去年快乐\n收入低是不安全至少是不快乐根源\n当然薪水最薄的职业往往也是\n最丢脸的案例最容易悲伤的依据\n混前程是无解的题荒愁的永动机\n报废到你幸福账面蹉跎的心底\n它在你怀念的女人背景中如疯般不可抑止\n像我们爱过那只落阳深处的布鲁斯\n\n跟这没人性的现实拼命拉锯\n越拼你越没头绪乏力的马卡告诉他弟\n“生活真够刺激，莫再逼我了，\n做个粪蛋也好，只要可以过下去”\n马卡你应该明白在大多数悲剧里面\n真正的伤心很少见马卡你得试着原谅\n如果故事的方向和你要的都不一样\n我多想你能有勇气重新开场\n\n你总不忘提醒再写上一些实况吧\n把最柔顺的曲调来刻画弯路里没路的人\n当歌声四起它应该是怎样的陈述句\n才不要你太唏嘘\n被自己打败的捣蛋鬼们已经很难\n去面对厄运吐露感情和热忱\n爱谈天的软骨头我们过白天然后等夜晚\n等夜晚只为喝得到明天\n\n当通往大结局的路啊正踏平所有的祖屋和田野\n快拿出力量去桃李芬芳\n去社会栋梁去掀起权力财富的巨浪\n去担负起自家的兴旺\n去变成大人和大人物变成一个\n只有钱才可以影响到情绪的臭傻逼\n你大概会挂得很无奈但是对于亲友团的颜面\n以及统治阶梯的审美观算是有交代\n\n\n","categories":["耳朵会说话"],"tags":["音乐"]},{"title":"从 0 到 1 构建项目，正确的打开方式到底是什么？","url":"/2022/03/23/think-from0to1/","content":"前言最近一年的时间里，我一直在一个创业团队做后端开发的工作，有时候也需要跟一下项目管理之类的统筹安排，通过处理不同的事情以及和不同角色的伙伴沟通，慢慢地我也产生了一些思考。\n受自身经验与所处环境限制，这些观点不一定对，如果有人看的话，希望你们可以辩证地去思考。\n\n正文由于阅历会逐渐增加，本文内容我也将会持续更新。\n态度认真很重要懒散的态度对团队有很大的消极影响，就算是完成了任务也没有完成责任。\n不一定都得非常厉害\n聚集一群都厉害的人这件事本身就非常困难\n水平有层次更有利于团队凝聚\n不一定都得非常厉害，但是不能拖后腿\n\n先有将后有兵先搞定核心业务的核心人物再考虑扩招，而不是跟学10年前的老话：“就差一个程序员了”。\n0 到 1 的重要程度，大于 1 到 100\n0 到 1 是一个质变，1 完成了，大家才会觉得靠谱\n1 到 100 是一个量变，大家不迷茫了以后才更有方向感、凝聚力\n\n完备性会比性能更重要一个 C 端接口的投入大量的人力去优化，响应时间从 200ms 减成 100ms，乍一听优化了很多很厉害，其实呢，不如去好好设计业务需求。\n最小颗粒度及时上线很重要从 0 到 1 的时间一定不要太长，团队里的所有人，都需要一个正反馈。\n\n确认比信任更重要即使某位成员非常靠谱，备受信任，也要得到明确的结果。\n不要过度优化以前的我认为：“写得慢也不要写得烂”，现在的我更觉得：“把控不住进度都是扯淡”。\n多给团队一些反馈，哪怕是不好的有任何不合理的地方，一定要及时提出。好的行为就奖励，不好的行为就惩罚，千万不要“秋后算账”。\n负责人得先舒服了没错，就是得到“舒服”的程度，领导的面部表情有时候能决定到团队一天的效率。\n一定满足不了所有用户需求，挑关键需求做，而不是全部都做\n0 到 1 是为那些特征用户服务的，这些人能用就行了\n在 1 到 100 的阶段再去追求覆盖率， 0 到 1 的阶段先解决问题\n\n每周都花时间去总结\n自己做了哪些决定（或者否定了哪些决定）\n大家有没有成长\n最关键的点：项目进度到底可不可控\n\n及时拍板，不要怕担责任项目中一定会有错误决策，不要害怕承担责任，大家如果都在犹豫就会很容易败北。\n在没有得到用户验证的情况下，不要凭空脑补需求凭空的需求只会拖慢从 0 到 1 的进度，而且这些需求也不一定都很正确，甚至随着时间的推进，这些需求也会“凭空消失”。\n业务大于技术虽然我是技术岗位，但是我还是坚持认为 技术一定要服务于业务，技术要用来解决需求。无论抗癌药物研究的多么先进，拉肚子的时候也不会去吃它。\n从 0 到 1 更需要的是服从，从 1 到 100 必须要发散\n说服从可能有点过于阶级化，但是在 0 到 1 的阶段中，产生决策之后就是需要大家一起去执行\n1 到 100 的时候更需要大家去提升自己，做到 100 而不是只到 50\n\n……结语受自身经验与所处环境限制，这些观点不一定对，如果有人看的话，希望你们可以辩证地去思考。","categories":["软件开发随想录"],"tags":["项目管理"]},{"title":"Mysql 中的悲观锁","url":"/2022/03/12/mysql-pcc/","content":"悲观锁是什么\n在关系数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。悲观锁是对数据的修改持悲观态度（认为数据在被修改的时候一定会存在并发问题），因此在整个数据处理过程中将数据锁定。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在应用层中实现了加锁机制，也无法保证外部系统不会修改数据）。\n\n简而言之，悲观锁主要用于保护数据的完整性。当多个事务并发执行时，某个事务对数据应用了锁，则其他事务只能等该事务执行完以后才能对该数据进行修改操作。\n举个例子在商品购买场景中，当有多个用户对某个库存有限的商品同时下单，若采用先查库存再减库存的方式来变更库存数量，当出现并发的时候很可能会出现“超卖”的现象。\n-- 1. 查询出商品库存\nselect stock from goods where id = 1;\n\n-- 2. 生成订单\n...\n\n-- 3. 库存减 1\nupdate goods set stock = stock - 1 where id = 1;\n\n\n这种减库存的方式在高并发访问的情况下很可能会出现问题：\n\n用户 A、B 都查询出库存为 1\n用户 A、B 都下单\nB 先生成订单，此时库存变更为 0\nA 生成订单之后，库存就变成了 -1\n\n使用悲观锁来处理：\n\nA 获取到库存的时候，B 用户阻塞\nA 完成减库存的事务之后，B 才可以获取到商品库存\n\n如何使用悲观锁要使用悲观锁，我们必须先关闭 Mysql 的自动提交属性。\n用法：SELECT … FOR UPDATE;\nset autocommit=0;\n\n-- 开始事务\nbegin;\n\n-- 1. 查询出商品库存\nselect stock from goods where id = 1 for update;\n\n-- 2. 生成订单\n...\n\n-- 3. 库存减 1\nupdate goods set stock = stock - 1 where id = 1;\n\n-- 提交事务\ncommit;\n\n\n当 A select stock from goods where id = 1 for update 之后，此时 B 来执行同样的事务时，B 会进入等待状态，等到 A 执行完 update 操作之后，B 的事务才会提交。\n行锁与表锁当执行 SELECT … FOR UPDATE; 的时候，Mysql 会把数据锁住，因此我们需要注意锁的级别。Mysql InnoDB 默认级别为行锁。当查询语句指定了主键时，Mysql 会执行行锁，否则执行表锁。一般：\n\n若指明主键，且结果集有数据，行锁\n若指明主键，结果集无数据，则无锁\n若无主键，且非主键字段无索引，则表锁\n若使用主键但主键不明确，则使用表锁\n\nInnoDB 的行锁是通过给索引上的索引项加锁实现的，因此：只有通过索引检索数据才会采用行锁，否则使用的是表锁。\n总结悲观锁采用的是「先获取锁再访问」的策略来保障数据的安全，但是加锁策略依赖数据库实现，会增加数据库的负担，且会增加死锁的发生几率。此外，对于不会发生变化的只读数据，加锁只会增加额外不必要的负担。在实际的实践中，对于并发很高的场景并不会使用悲观锁，因为当一个事务锁住了数据，那么其他事务都会发生阻塞，会导致大量的事务发生积压拖垮整个系统。\n","categories":["技术分享"],"tags":["SQL"]},{"title":"JWT 的一点知识","url":"/2022/03/07/jwt/","content":"JWT 是什么\nJSON Web Token (JWT) 是一个开放标准(RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为 JSON 对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。\n\nJWT 长啥样JWT 是由三段信息构成的，将这三段信息用 . 连接在一起就构成了 JWT。\n\nHeader\nPayload\nSignature\n\n类似：Header.Payload.Signature\nHeaderHeader 部分是一个 JSON 对象，描述 JWT 的元数据。承载两部分信息：\n\n声明类型，JWT 的类型统一写为 JWT\n声明加密的算法，通常直接使用 HMAC SHA256\n\n比如：\n&#123;\n  'typ': 'JWT',\n  'alg': 'HS256'\n&#125;\n然后将这部分信息进行 Base64URL 算法转换成字符串，就构成了 JWT 的第一部分。\nPayloadPayload 部分用来存放实际需要传递的数据，通常有 7 个字段：\niss (issuer)：签发人\nexp (expiration time)：过期时间\nsub (subject)：主题\naud (audience)：受众\nnbf (Not Before)：生效时间\niat (Issued At)：签发时间\njti (JWT ID)：编号\n\n除了这些字段外，我们一般会定义一些私有字段来传递业务中的数据，比如：\n&#123;\n  \"name\": \"maria\",\n  \"uid\": 100001\n&#125;\nJWT 默认是不加密的，所以不要将敏感信息存储在 JWT 中\n然后将这部分信息进行 Base64URL 算法转换成字符串，就构成了 JWT 的第二部分。\nSignatureSignature 部分是对前两部分的签名，防止数据遭到篡改。\n首先，需要指定一个密钥（secret），这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名\nHMACSHA256(\n  base64UrlEncode(header) + \".\" +\n  base64UrlEncode(payload),\n  secret)\n\n算出签名之后，将 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用 . 分隔，就得到了 JWT。\nJWT 怎么用客户端收到服务器返回的 JWT 之后，可以将它存储在 cookie 里，也可以存储在 localStorage 之中。此后，客户端每次和服务器通信都带上这个 JWT，服务器收到之后进行解密校验，根据 Signature 判断是否被篡改。流程：\nJWT 应用JWT 中间件只允许一个用户登录将用户每次登录之后产生的 token 存入 redis 中， 用用户 id 做为 key。此 id 第二次登录的时候，上一次的 token 就会被覆盖。但是，在 token 未失效的情况下，第一次的 token 还是可以解码出来，payload 中的信息和第二次的一样，从而无法实现新旧 token 的对比。所以在创建 token 的时候向其中写入一个随机字符串，客户端请求带上的 token 中的 uuid 如果与 redis 存的不一样，则该 token 应该被踢下线。听起来和 session 相比好像也没什么优雅的地方。\n优缺点\nJWT 默认不加密，不要将敏感数据写入 JWT\n服务端无状态，不保存，易于扩展\n支持跨域认证（放 cookie 里不能跨域，但是放 header 里可以跨域）\n尽量使用 https\nJWT 一旦下发之后就无法废弃或者更改权限，所以有效时间尽可能短\n\n参考文章：\n\nJSON Web Token 入门教程 by: 阮一峰\nIntroduction to JSON Web Tokens\n\n","categories":["技术分享"],"tags":["BackEnd"]},{"title":"【重学前端】之 CSS","url":"/2022/03/02/study-fe-css/","content":"前言【重学前端】系列推荐： HTML 篇\nCSS 是一种描述 HTML 文档样式的语言。CSS 是前端需要掌握的最基本的技能，决定了一个程序员的下限。\n正文盒模型CSS 盒模型本质上是一个盒子，它包括：边距、边框、内容。\nCSS 盒模型包括：IE 盒模型（怪异盒模型） 和 W3C 盒模型（标准盒模型）\n标准盒模型宽度 = width + margin(left &amp; right) + padding(left &amp; right) + border(left &amp; right)\n怪异盒模型宽度 = width + margin(left &amp; right)width 已经包含了 padding 和 border 的值\n选择器\nid 选择器 (#myid)\n类选择器 (.myclass)\n属性选择器 (a[href] {color:red;})\n伪类选择器 (a:hover, li:nth-child)\n标签选择器 (div, h1,p)\n相邻选择器 (h1 + p)\n子选择器 (ul &gt; li)\n后代选择器 (li a)\n通配符选择器 (*)\n\n优先级：\n\n!important\n内联样式\nid 选择器\n类选择器 / 属性选择器 / 伪类选择器\n元素选择器 / 伪元素选择器\n关系选择器 / 通配符选择器\n\n!important &gt; 行内样式 &gt; id 选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性\nBFCBFC: Block Formatting Context, 块级格式化上下文。BFC 是一个独立的渲染区域，规定了内部的 box 如何布局，并且这个区域的子元素不会影响到外面的元素，计算 BFC 高度的时候，浮动元素也参与计算。\nBFC 的布局规则\n\n内部的 box 会在垂直方向一个接一个排列\nbox 垂直方向的距离由 margin 决定，属于同一个 BFC 的两个相邻 box 的 margin 会发生重叠\nBFC 的区域不会与 float box 发生重叠\nBFC 是一个独立容器，里面元素不会影响到外面元素\n计算 BFC 的高度的时候，浮动元素也参与计算高度\n元素的类型和 display 属性决定了这个 box 的类型，不同类型的 box 会参与不同的 formatting context\n\n如何创建 BFC\n\n根元素，即 HTML 元素\nfloat 的值不为 none\nposition 为 absolute 或者 fixed\ndisplay 的值为 inline-block\noverflow 的值不为 visible\n\nBFC 使用场景\n\n去除边距重叠\n清除浮动\n\nflexflex 是 flexible box 的缩写，意为“弹性布局”。通过指定容器的 display 属性为 flex 即可。\n容器属性：\n\nflex-direction: row | row-reverse | column | column-reverse;\nflex-wrap: nowrap | wrap | wrap-reverse;\njustify-content: flex-start | flex-end | center | space-between | space-around;\nalign-items: flex-start | flex-end | center | baseline | stretch;\nalign-content: flex-start | flex-end | center | space-between | space-around | stretch;\n\n元素属性：\n\norder 属性：定义项目的排列顺序，顺序越小，排列越靠前，默认为 0\nflex-grow 属性：定义项目的放大比例，即使存在空间，也不会放大\nflex-shrink 属性：定义了项目的缩小比例，当空间不足的情况下会等比例的缩小，如果定义个 item 的 flow-shrink 为 0，则为不缩小\nflex-basis 属性：定义了在分配多余的空间，项目占据的主轴空间\nflex: 是 flex-grow 和 flex-shrink、flex-basis 的简写，默认值为 0 1 auto\nalign-self: 允许单个项目与其他项目不一样的对齐方式，可以覆盖align-items: 默认属性为 auto，表示继承父元素的 align-items\n\n媒体查询.example &#123;\n  padding: 20px;\n  color: white;\n&#125;\n/* Extra small devices (phones, 600px and down) */\n@media only screen and (max-width: 600px) &#123;\n  .example &#123;\n    background: red;\n  &#125;\n&#125;\n\n/* Small devices (portrait tablets and large phones, 600px and up) */\n@media only screen and (min-width: 600px) &#123;\n  .example &#123;\n    background: green;\n  &#125;\n&#125;\n\n/* Medium devices (landscape tablets, 768px and up) */\n@media only screen and (min-width: 768px) &#123;\n  .example &#123;\n    background: blue;\n  &#125;\n&#125;\n\n/* Large devices (laptops/desktops, 992px and up) */\n@media only screen and (min-width: 992px) &#123;\n  .example &#123;\n    background: orange;\n  &#125;\n&#125;\n\n/* Extra large devices (large laptops and desktops, 1200px and up) */\n@media only screen and (min-width: 1200px) &#123;\n  .example &#123;\n    background: pink;\n  &#125;\n&#125;\n\n移动端适配预处理 less | sass动画","categories":["技术分享"],"tags":["CSS","FrontEnd"]},{"title":"【重学前端】之 HTML","url":"/2022/03/02/study-fe-html/","content":"前言最近面试了很多前端，从应届生小白到三年经验的老炮，大家好像都很“看不起”面试被问 HTML 问题这回事。前端虽然真的很基础，但是它真的也需要被重视。\n所以我打算系统的整理一下前端所需要的知识，本文为 HTML 相关内容，后续还会有 JavaScript、CSS、框架、工程化、Node等。\n正文什么是 HTMLHTML 指的是超文本标记语言，不是编程语言，是标记语言。使用标签来描述网页内容。\n什么是语义化通过 HTML 语义化标签来表明其内部内容的意义。\n好处有：\n\n有利于 SEO、爬虫\n代码可读性更高\n访问性更好\n\n语义标签（元素）：\n\n\n\n标签\n描述\n\n\n\n&lt;article&gt;\n定义文章\n\n\n&lt;aside&gt;\n定义页面内容以外的内容\n\n\n&lt;details&gt;\n定义用户能够查看或隐藏的额外细节\n\n\n&lt;figure&gt;\n规定自包含内容，比如图示、图表、照片、代码清单等\n\n\n&lt;figcaption&gt;\n定义 &lt;figure&gt; 元素的标题\n\n\n&lt;footer&gt;\n定义文档或节的页脚\n\n\n&lt;header&gt;\n规定文档或节的页眉\n\n\n&lt;main&gt;\n规定文档的主内容\n\n\n&lt;mark&gt;\n定义重要的或强调的文本\n\n\n&lt;nav&gt;\n定义导航链接\n\n\n&lt;section&gt;\n定义文档中的节\n\n\n&lt;summary&gt;\n定义 &lt;details&gt; 元素的可见标题\n\n\n&lt;time&gt;\n定义日期/时间\n\n\nHTML 元素HTML 属性块HTML 元素一般被分为块级元素和内联元素。块级元素显示的时候会换行，内联元素不换行。\n类 (class) 与 idclass对 HTML 元素进行分类，可以为相同的类设置同样的样式。\nidid 指定 HTML 元素的唯一 id，在 HTML 文档中必须唯一。\n&lt;head&gt;: 所有头部元素的容器。\n头部元素有：\n\n\n\n标签\n描述\n\n\n\n&lt;title&gt;\n定义文档标题\n\n\n&lt;base&gt;\n定义页面上所有链接的默认地址或默认目标\n\n\n&lt;link&gt;\n引用外部资源\n\n\n&lt;meta&gt;\n定义关于 HTML 文档的元数据\n\n\n&lt;script&gt;\n引用或者定义 js\n\n\n&lt;style&gt;\n定义文档的样式信息\n\n\nCanvasHTML5 的 canvas 元素使用 js 在网页上绘制图像。canvas 元素本身是没有绘图能力的，所有的绘制工作必须在 js 内部完成。\nHTML 媒体（视频、音频）HTML5HTML5 是最新的 HTML 标准。\n本地存储web 应用程序能够在用户浏览器中对数据进行本地的存储（localStorage &amp; sessionStorage）。\n必须在 同源（同域名、同端口、同协议）下才能读取修改，sessionStorage 还需要在同窗口。\nlocalStorage 永久有效，不清空的话一直存在；sessionStorage 关闭窗口会被清空。\n都采用标准的键值对存储，键必须唯一。\n大小都是 5M.\n","categories":["技术分享"],"tags":["FrontEnd"]},{"title":"My utils","url":"/2022/02/28/my-utils/","content":"前言在日常开发中经常会有很多命令或者工具，虽然它们只是偶尔会被使用到，但是每次用起来都得去 google，所以此篇文章用来记录这些 utils.\n都有些啥查看本地已经安装的所有的 npm 包npm list -g --depth 0 \n\n# 更新\nnpm update -g xxx\n\n# 删除\nnpm uninstall -g xxx\n\n查看指定时间范围内 npm 包的下载总量https://npm-stat.com/charts.html?package=xxx-xxx&amp;from=&amp;to=\n\nMac 下显示隐藏文件Command+Shift+. 可以显示隐藏文件、文件夹，再按一次，恢复隐藏\n\ngit 从指定分支 clone 代码git clone -b branch_name git@github.com:xxx/xxx.git\n","categories":["技术分享"],"tags":["utils"]},{"title":"微信小程序全局接管页面分享","url":"/2022/02/22/wxapp-share/","content":"前言分享是小程序裂变的一个非常重要的渠道，但是微信小程序每个页面都要写 onShareAppMessage 来配置分享内容（标题、图片、参数等），页面多的时候写起来重复性太高，所以想出能不能直接全局配置分享，统一接管。\nonShareAppMessage微信小程序开发文档·onShareAppMessage\n\n由于各个小程序开发框架写起来都不太一样，所以就改成了原生的代码\nonShareAppMessage: function () &#123;\n  return &#123;\n    title: '转发标题',\n    path: '转发路径',\n    imageUrl: '转发卡片图片'\n  &#125;\n&#125;,\n\n\n查阅文档发现，onShareAppMessage 是一个事件处理函数，用户通过点击小程序的右上角...触发，或者通过页面上的 &lt;button open-type=&#39;share&#39;&gt; 来触发，所以只需要在小程序启动的时候重写一下 onShareAppMessage 就可以了。\nonLaunch: function ()&#123;\n    wx.onAppRoute(() => &#123;\n        console.log(getCurrentPages());\n\n        const pages = getCurrentPages();\n        const current_page = pages[pages.length-1];\n        current_page.onShareAppMessage = () => &#123;\n          return &#123;\n            title: '',\n            path: current_page.route,\n            imageUrl: '转发卡片图片'\n          &#125;\n        &#125;\n    &#125;);\n&#125;\n","categories":["技术分享"],"tags":["小程序","Taro"]},{"title":"ssh2 + mysql ，node写接口如何更“安全”的操作数据库","url":"/2022/02/21/ssh2-mysql/","content":"前言为了网络安全起见，数据库和后端服务一般不会直接部署在同一台机器上，且一般也不允许直接用账户+密码的方式直接连接，通常采取的方案是通过 ssh 的方式进行连接。\n项目已经封装成 npm 包：ssh2-connect-mysql\ngithub 地址：ssh2-connect-mysql\n步骤\n建立 ssh 连接\n与 mysql 建立连接\n得到 mysql 操作句柄\n\n实现方式const client = require(\"ssh2\").Client;\nconst mysql = require('mysql2');\n\nconst _client = new client();\n\n// see config: https://github.com/mscdex/ssh2\nconst ssh_conf = &#123;\n  host: 'xxx.xxx.xx.1',\n  port: 22,\n  username: 'maria',\n  privateKey: fs.readFileSync('/path/to/my/key')\n&#125;;\n\n// see config: https://github.com/sidorares/node-mysql2\nconst db_conf = &#123;\n  host: 'xxx.xxx.xx.2',\n  user: 'realzzzdb',\n  password: 'qwer123..',\n  database: 'mydb'\n&#125;;\n\n// 建立 ssh 连接\n_client.on(\"ready\", function () &#123;\n    _client.forwardOut(\n      \"127.0.0.1\",\n      12345,\n      db_config.host,\n      db_config.port,\n      function (err, stream) &#123;\n        if (err) &#123;\n          _client.end();\n          return renject(\"Connection failed.\");\n        &#125;\n\n        // 得到 stream\n        db_config.host = 'localhost';\n        db_config.stream = stream;\n\n        // 得到 mysql 的操作句柄\n        _sql = mysql.createConnection(db_config);\n        \n      &#125;\n    ).connect(ssh_config); // ssh 连接的参数\n  &#125;);\n\n更好的使用，封装成 npm 包npm package: ssh2-connect-mysql\ngithub page: ssh2-connect-mysql\n","categories":["技术分享"],"tags":["BackEnd","Node"]},{"title":"前端监控埋点方案（GIF）","url":"/2022/02/17/gif-page-tracking/","content":"为什么需要埋点互联网 2.0 时代的产品比较喜欢讲究千人千面，运营与产品团队非常注重观察用户使用产品的行为轨迹，从而能够精准推荐到“猜你喜欢”。研发团队也会非常关注产品的性能和异常，确保产品的高性能以及高安全性。\n埋点 &amp; 上报埋点（监控）内容\n用户数据\n\nPV / UV\n点击位置 / 浏览位置 / 浏览时间\n入口\n触发的行为\n……\n\n\n页面性能\n\n不同用户不同机型不同系统加载时间\n接口请求时间 / 页面渲染时间\n……\n\n\n系统异常\n\n系统报错\n……\n\n\n\n上报常见上报方式：\n\n请求接口\n\n请求普通文件\n\n请求图片\n\n\n弊端：\n\n请求接口：场景复杂，容易出现跨域\n\n请求普通文件（js/css/ttf 等）：浏览器创建 DOM 树之后才会请求资源节点，大量请求 js/css 等资源还会阻塞页面渲染\n\n\n选择图片打点的原因：\n图片打点不需要操作 DOM，得利于 img 的 src 属性，只需要在 js 中 new 一个 image 对象就可以发起请求，而且也没有页面阻塞的问题，且页面关闭的时候，采用 img 发出的请求也不会被取消。\n\nlet img = new Image();\nimg.src = 'https://static.example.com/track.gif?data=xxx';\n\n图片为什么选择 GIF同样是 1x1 像素的透明图片，GIF 的体积最小。\n\n最小的 BMP 文件需要 74 个字节\n最小的 PNG 需要 67 字节\n最小的 GIF 需要 43 字节\n\n前端埋点选择 GIF 的主要原因\n不跨域\n不阻塞页面加载\n体积小\n闭页面的时候图片的请求还能发出去\n\n","categories":["技术分享"],"tags":["FrontEnd"]},{"title":"提升一点点也是值得的，使用 box-shadow 的时候应该避免重绘","url":"/2022/02/09/box-shadow/","content":"前言在渲染长列表的时候，经常有这样的需求：悬浮在列表的 item 上，会“高亮”显示当前的 hover 内容，虽然数据量少的时候没有明显的卡顿感受，但是如果数据量过大或者操作过于频繁，就会感受到页面有一点点的“呆滞”。\n原因直接动态添加 box-shadow 属性的时候，每一次操作都会进行重绘 (repaint)，会损耗页面渲染的性能。\n优化方案通过修改伪类元素的透明度来实现 box-shadow\n原理：通过改变透明度，这样其实是从一个非默认值来更新它的值，不需要进行重绘。\n写法对比old&lt;div class=\"old\">&lt;/div>\n\n.old &#123;\n  padding: 20px;\n  background-color: #ffffff;\n  transition: 0.2s;\n&#125;\n.old:hover &#123;\n  box-shadow: 0 0 10px 0 rgba(0, 0, 0, 0.3);\n&#125;\n\nnew&lt;div class=\"new\">&lt;/div>\n\n\n设置一个空的伪元素，设置它的透明度为0\n\n.new::after &#123;\n    content: \"\";\n    position: absolute;  \n    top: 0;\n    right: 0;\n    bottom: 0;  \n    left: 0;\n    z-index: -1;\n    box-shadow: 0 0 10px 0 rgba(0, 0, 0, 0.3);\n    opacity: 0;\n    will-change: opacity;\n    transition: 0.2s;\n&#125;\n\n\n通过鼠标悬停，恢复它的透明度\n\n.new:hover::after &#123;\n  opacity: 1;\n&#125;\n\n效果\n","categories":["技术分享"],"tags":["Web","CSS"]},{"title":"My Custom CSS Reset","url":"/2022/01/27/css-reset/","content":"前言每当我开始一个新项目时，首要的任务就是处理 CSS 语言中的那些边边角角的问题。为了解决这些问题，通常会使用自定义的一组基础样式。\nMy CSS Reset持续更新…\n/*\n  Custom CSS Reset\n*/\n*, *::before, *::after &#123;\n  box-sizing: border-box;\n&#125;\n* &#123;\n  margin: 0;\n&#125;\nhtml, body &#123;\n  height: 100%;\n&#125;\nbody &#123;\n  line-height: 1.5;\n  -webkit-font-smoothing: antialiased;\n&#125;\nimg, picture, video, canvas, svg &#123;\n  display: block;\n  max-width: 100%;\n&#125;\ninput, button, textarea, select &#123;\n  font: inherit;\n&#125;\np, h1, h2, h3, h4, h5, h6 &#123;\n  overflow-wrap: break-word;\n&#125;\n#root, #__next &#123;\n  isolation: isolate;\n&#125;\n\n\n@mixin flex($f_d: column, $j_c: normal, $a_i: normal) &#123;\n  display: flex;\n  flex-direction: $f_d;\n  justify-content: $j_c;\n  align-items: $a_i;\n&#125;\n\n@mixin w_h($w: auto, $h: auto) &#123;\n  @if $w != auto &#123;\n    width: #&#123;$w&#125;px;\n  &#125; @else &#123;\n    width: auto;\n  &#125;\n  @if $h != auto &#123;\n    height: #&#123;$h&#125;px;\n  &#125; @else &#123;\n    height: auto;\n  &#125;\n&#125;\n\n@mixin font($s: 24, $c: #444, $l: 24, $f: 400) &#123;\n  font-size: #&#123;$s&#125;px;\n  color: #&#123;$c&#125;;\n  line-height: #&#123;$l&#125;px;\n  font-weight: #&#123;$f&#125;;\n&#125;","categories":["小轮子"],"tags":["Web","CSS"]},{"title":"Taro 中使用 Vuex & 数据持久化存储","url":"/2022/01/10/taro-vuex/","content":"前言许久没有关注小程序的生态圈发展，这两天发现在造轮子这一块，各大厂商都玩的天花乱坠。最近打算开始试试由京东开发的 Taro，记录一下上手体验以及遇到的一些小问题。\n是什么官方说明：\n\nTaro 是一个开放式跨端跨框架解决方案，支持使用 React/Vue/Nerv 等框架来开发 微信 / 京东 / 百度 / 支付宝 / 字节跳动 / QQ / 飞书 小程序 / H5 / RN 等应用。\n\n简言之，Taro 旨在：只编写一套代码，就能够多端运行。\n上手具体流程可参考官方文档：Taro\n数据状态管理 (Vuex)由于我选择的是 Vue 来开发，所以状态管理选择的是 Vuex.\n\n安装 vuex\nyarn add vuex\n项目集成\n\n新建 src/store/index.js\n\n  import Vue from \"vue\";\nimport Vuex from \"vuex\";\nVue.use(Vuex);\nexport default new Vuex.Store(&#123;\n  state: &#123;\n    userinfo: &#123;\n      nickname: \"zhangsan\"\n    &#125;\n  &#125;,\n  mutations: &#123;&#125;\n&#125;);\n\napp.js 中引入 store\n\n  // 部分代码\nimport store from './store';\n\nconst App = &#123;\n  store,\n  render(h) &#123;\n    return h('block', this.$slots.default)\n  &#125;\n&#125;\n\nexport default App\n\n至此发现，和 Vue 的开发也没什么区别\n数据持久化存储选用 vuex-persistedstate\n\n安装\nyarn add vuex-persistedstate\n项目集成\n\n改造 src/store/index.js\n\n  import Vue from \"vue\";\nimport Vuex from \"vuex\";\nimport persistedState from \"vuex-persistedstate\";\nVue.use(Vuex);\nexport default new Vuex.Store(&#123;\n  state: &#123;\n    userinfo: &#123;\n      nickname: \"zhangsan\"\n    &#125;\n  &#125;,\n  mutations: &#123;\n    testChangeNickname: (state, payload) => &#123;\n      state.userinfo.nickname = payload.nickname\n    &#125;\n  &#125;,\n  plugins: [\n    persistedState()\n  ]\n&#125;);\n\n\n在 state 中特别加入 userinfo: &#123; nickname: &#39;zhangsan&#39; &#125;, mutations 中加入 testChangeNickname 来测试调用。\n编译发现很尴尬，报错了。\nsetItem of undefined\n看起来是 persistedState 的 storage 默认使用的是 window 所导致的，而小程序里肯定不能直接调用 window.\n\n再改 src/store/index.js\n\n  // 部分代码\nimport Taro from '@tarojs/taro'\nplugins: [\n  persistedState(&#123;\n    storage: &#123;\n      getItem: key => &#123;\n        return Taro.getStorageSync(key)\n      &#125;,\n      setItem: (key, value) => &#123;\n        Taro.setStorageSync(key, value)\n      &#125;,\n      removeItem: key => &#123;\n        Taro.removeStorageSync(key)\n      &#125;\n    &#125;\n  &#125;)\n]\n  \n将 getItem、setItem、removeItem 全部改成 Taro 调用\n编译正常。\n\n\n\n业务测试\n\n获取 state\n\ncomputed: &#123;\n  nickname() &#123;\n    return this.$store.state.userinfo.nickname\n  &#125;\n&#125;,\n\n\n触发 mutations\n\nthis.$store.commit('testChangeNickname', &#123; nickname: 'lisi' &#125;)\n\n结语至此，完成 Taro 中使用 Vuex &amp; 数据持久化存储。\n持续踩坑中…\n","categories":["技术分享"],"tags":["小程序","Taro"]},{"title":"自己写一个掘金自动签到的脚本","url":"/2021/11/29/auto-juejin/","content":"前言1024 的时候我发现掘金的福利兑换礼品真的是白菜价，奈何如此少的矿石，我依然没有。我每天开始去签到，只是为了来年 1024 的时候去挥霍一番，可是我发现每天都念叨这件事情属实让我很不舒服，因为只有女朋友可以让我每天如此思念 T_T\n所以我决定写个自动签到的脚本来帮我干这件事情 (:\n功能点自动签到聪明的人打开浏览器控制台就可以找到签到对应的接口:\n\n查询今日是否已经签到：\n\nhttps://api.juejin.cn/growth_api/v1/get_today_status\n\n\n签到：\n\nhttps://api.juejin.cn/growth_api/v1/check_in\n\n这样一来就非常简单了，先获取一下签到状态，没签到的去签个到：\n// 查询今日是否已经签到\nconst getTodayCheckStatus = async () => &#123;\n  const cookie = '从浏览器的请求头里 copy 一个 cookie';\n  let &#123; data &#125; = await axios(&#123;\n    url: 'https://api.juejin.cn/growth_api/v1/get_today_status',\n    method: \"get\",\n    headers: &#123;\n      Cookie: cookie,\n    &#125;,\n  &#125;);\n  return &#123;\n    error: data.err_no !== 0,\n    isCheck: data.data,\n  &#125;;\n&#125;;\n\n// 签到\nconst checkIn = async () => &#123;\n  let &#123; error, isCheck &#125; = await getTodayCheckStatus();\n  if (error) &#123;\n    console.log('验证签到错误');\n    return;\n  &#125;\n  if (isCheck) &#123;\n    console.log('已经签到');\n    return;\n  &#125;\n  const cookie = '从浏览器的请求头里 copy 一个 cookie';\n  let &#123; data &#125; = await axios(&#123;\n    url: 'https://api.juejin.cn/growth_api/v1/check_in',\n    method: \"post\",\n    headers: &#123;\n      Cookie: cookie,\n    &#125;,\n  &#125;);\n  if (data.err_no) &#123;\n    console.log('签到失败');\n  &#125; else &#123;\n    console.log('签到成功');\n  &#125;\n&#125;;\n\n顺带免费抽奖聪明的人又打开了浏览器的控制台找到了抽奖对应的接口:\n\n获取抽奖配置：\n\nhttps://api.juejin.cn/growth_api/v1/lottery_config/get\n\n\n发起抽奖\n\nhttps://api.juejin.cn/growth_api/v1/lottery/draw\n\n这样一来就又非常简单了，先获取一下抽奖状态，没抽奖的去抽个奖：\nconst getTodayLotteryStatus = async () => &#123;\n  const cookie = '从浏览器的请求头里 copy 一个 cookie';\n  let &#123; data &#125; = await axios(&#123;\n    url: 'https://api.juejin.cn/growth_api/v1/lottery_config/get',\n    method: \"get\",\n    headers: &#123;\n      Cookie: cookie,\n    &#125;,\n  &#125;);\n  if (data.err_no) &#123;\n    return &#123;\n      error: true,\n      isLotteryed: false,\n    &#125;;\n  &#125; else &#123;\n    return &#123;\n      error: false,\n      isLotteryed: data.data.free_count === 0,\n    &#125;;\n  &#125;\n&#125;;\n\n// 抽奖\nconst draw = async () => &#123;\n  let &#123; error, isLotteryed &#125; = await getTodayLotteryStatus();\n  if (error || isLotteryed) &#123;\n    console.log('抽过啦');\n    return;\n  &#125; \n  const cookie = '从浏览器的请求头里 copy 一个 cookie';\n  let &#123; data &#125; = await axios(&#123;\n    url: 'https://api.juejin.cn/growth_api/v1/lottery/draw',\n    method: \"post\",\n    headers: &#123;\n      Cookie: cookie,\n    &#125;,\n  &#125;);\n  if (data.err_no) &#123;\n    console.log('抽奖失败啦');\n    return;\n  &#125;\n  console.log('抽奖结果:\\n' + data);\n&#125;;\n\n失败了再顺带给我发个邮件邮件服务可以参考：nodemailer\nconst sendEmail = async (subject, html) => &#123;\n  // xxx\n&#125;;\n\n将上面函数里失败的 console.log() 替换成邮件提醒 await sendEmail()\n丢到服务器上每天定时执行let job = new Cron(\n  \"10 10 10 * * *\",\n  async () => &#123;\n    await checkIn();\n    await draw();\n  &#125;,\n  null,\n  true,\n  'Asia/Shanghai'\n);\n\njob.start();\n\n注意事项由于 cookie 会过期，所以失败之后可以尝试在浏览器里重新 copy 一个 cookie 到脚本里执行。\n","categories":["技术分享"],"tags":["Web","BackEnd"]},{"title":"珍品收藏links","url":"/2021/11/18/favorite-links/","content":"珍品收藏dev开发常见：\n\ntinypng\n\nbase64图片在线转换工具\n\nUU在线工具\n\ni Hate Regex - The Regex Cheat Sheet\n\nRGB颜色值与十六进制颜色码转换工具\n\nAn image cache &amp; resize service.\n\nNavicat for MySQL 15注册激活\n\n插图-Illustrations | unDraw\n\n插图-404 Illustrations\n\nError 404 png\n\nCarbon | Create and share beautiful images of your source code\n\nAnimista - CSS Animations on Demand\n\n表情速查\n\npublic APIs\n\n统计 npm 包下载数量\n\n\ndaily生活类：\n\n违法不良信息举报中心\n\nGenerate a Random Name - Fake Name Generator\n\n免费短信接收-有信云短信\n\nTemp Mail - 临时性 - 匿名电子邮件\n\n消除图片中的背景 – remove.bg\n\nsquoosh-图片压缩\n\nthis person does not exist\n\n手写思维导图\n\n\n","categories":[],"tags":[]},{"title":"【图片压缩二】使用node批量压缩图片","url":"/2021/10/22/image-node/","content":"前言相比于一些APP或者在线网站，有时候我们的业务工程里需要集成压缩图片的功能，node环境下，imagemin 就非常适合做这件事情。\n概述imagemin是一种插件模式的压缩工具，需要根据所需压缩图片的格式来按需加载对应的插件。\nnpm install imagemin\nnpm install imagemin-jpegtran // OR imagemin-mozjpeg\nnpm install imagemin-pngquant\nnpm install imagemin-svgo\nnpm install imagemin-imagemin-webp\n\n使用方法\n压缩目录images下的图片文件，输出文件到目录下：\n\nimport imagemin from 'imagemin';\nimport imageminMozjpeg  from 'imagemin-mozjpeg';\nimport imageminPngquant from 'imagemin-pngquant';\n\n(async () => &#123;\n  const files = await imagemin(['images/*.&#123;jpg,png&#125;'], &#123;\n    destination: 'build',\n    plugins: [\n      imageminMozjpeg(&#123;\n        quality: 50,\n      &#125;),\n      imageminPngquant(&#123;\n        quality: [0.5, 0.8]\n      &#125;)\n    ]\n  &#125;);\n  console.log(files);\n&#125;)();\n\n\n修改成函数式：传入图片的base64，输出压缩后的base64\n\nimport imagemin from 'imagemin';\nimport imageminMozjpeg  from 'imagemin-mozjpeg';\nimport imageminPngquant from 'imagemin-pngquant';\n\n(async () => &#123;\n  const base64Str = '';\n  const ogBuffer = Buffer.from(base64Str, \"base64\");\n\n  const files = await imagemin.buffer(ogBuffer, &#123;\n    plugins: [\n      imageminMozjpeg(&#123;\n        quality: 50,\n      &#125;),\n      imageminPngquant(&#123;\n        quality: [0.5, 0.8]\n      &#125;)\n    ]\n  &#125;);\n\n  console.log(files.toString('base64'));\n\n&#125;)();\n","categories":["小轮子"],"tags":["Node","图片"]},{"title":"根据 IP 限制访问接口的频率","url":"/2021/10/20/ratelimit/","content":"前言业务上线之后，经常会出现一些来路不明的人在持续不断的请求业务接口，这些请求就算没有产生数据安全问题也会对业务服务器产生一些压力，那么如何拦截这些请求就成了一个不得不去面对的问题。解决方案有很多种，其中之一就是：根据 IP 限制访问接口的频率\n设计思路以10秒钟之内请求次数不超过20次为例\n\n把请求的 ip 和接口路由 path 拼接起来作为 key，把请求的次数作为 value，存进Redis，并设置过期时间为10秒\n\n第一次请求设置 value 为1，以后每次请求 value + 1\n\n每一次请求都重置过期时间，并且判断 value 是否大于 10\n\n如果没过期，且 value 大于 10，则是应该被限制的请求\n\n\n伪代码以 eggjs/midway 中间件为例\n\nconst cacheName = `$&#123;ip&#125;-$&#123;path&#125;`; // key\n\nconst ttl = await redisService.ttl(cacheName); // key是否有剩余时间\n\nif (ttl > 0) &#123;\n  const count = await redisService.read(cacheName); // key已经请求的次数\n  if (count &amp;&amp; +count &lt; 20) &#123;\n    // 如果还没到20次，次数加1，重置过期时间，正确返回\n    await redisService.write(cacheName, count + 1, ttl);\n    await next();\n  &#125; else &#123;\n    // 次数大于阈值，拦截，返回429\n    throw Error('too many requests', 429);\n  &#125;\n&#125; else &#123;\n   // ttl &lt; 0, 重新写\n  await redisService.write(cacheName, 1, 10);\n  await next();\n&#125;\n","categories":["技术分享"],"tags":["BackEnd","Node"]},{"title":"【图片压缩一】Python结合TinyPNG批量压缩图片","url":"/2021/10/19/image-tinypng-py/","content":"前言在使用TinyPng压缩图片的时候经常会遇到需要一次性压缩很多张，网站使用起来需要本地选择图片然后上传再下载压缩之后的图片，很不方便，所以想搞一个脚本在本地运行可以递归压缩文件夹及子文件夹中的所有图片。\n准备工作安装一下tinify\npip install --upgrade tinify\n\n核心科技import tinify\nimport os\nimport os.path\n\ntinify.key =\"XXXXXXXX\" # AppKey--tinypng申请的key\nfromPath =\"/Users/xxx/Desktop/temp-test/pic-test/source\" # source path\ntoPath =\"/Users/xxx/Desktop/temp-test/pic-test/dest\" # dest path\n\nfor root, dirs, files in os.walk(fromPath):\n newToPath = toPath\n if len(root) > len(fromPath):\n  innerPath= root[len(fromPath):]\n  if innerPath[0] == '/':\n   innerPath = innerPath[1:]\n  newToPath =  os.path.join(toPath,innerPath)\n\n for name in files:\n  newFromFilePath = os.path.join(root, name)\n  newToFilePath = os.path.join(newToPath, name)  \n  fileName, fileSuffix = os.path.splitext(name)\n  if fileSuffix == '.png' or fileSuffix == '.jpg':\n   source = tinify.from_file(newFromFilePath)\n   source.to_file(newToFilePath)\n  else:\n   pass\n\n for dirName in dirs:\n  os.mkdir(os.path.join(newToPath, dirName))\n\n","categories":["小轮子"],"tags":["图片","Python"]},{"title":"我不希望别人可以随意调试我的网站代码","url":"/2021/08/28/browser-debugger/","content":"起因在某次爬虫（科学获取网站资讯数据）的时候，我打开了该网站的控制台，通过Network 和Sources 两个Tab选项，我发现很容易就调试出了它的接口请求参数，当时就整个一洋洋得意。但是我转念一想，如果是我自己的网站，我不希望别人也可以这样轻而易举地调试我的页面，我应该怎么防止呢？\n预防手段在开发过程中，我们通常会在页面上打很多断点用来调试，我突发奇想，如果有人打开页面的控制台，我让他一直处于debugger当中，这样不就让他没法进行下一步了吗？\n这个简单，几行代码的事情\n(() => &#123;\n  setInterval(() => &#123;\n    debugger;\n  &#125;, 100);\n&#125;)();\n\n这段代码的作用是：通过一直处于debugger状态来阻塞你程序的执行，没办法在Source Tab中对js进行加断点，没办法继续调试程序的执行逻辑。但是Sources Tab选项中，我们可以添加Ignore List来过滤掉我们加的debugger\n这样设置，页面中的debugger就不生效了…\n但是，只要思想不滑坡，困难总比方法多\n(() => &#123;\n  setInterval(() => &#123;\n    Function(\"debugger\")();\n  &#125;, 100);\n&#125;)();\n\nFunction生成的debugger会在每一次执行的时候都开启一个临时的js文件，而你的Ignore List只能遇到一次加一次，永远落后我的脚步&#x1F61B;\n说干就干既然这样，我不如直接写个webpack插件，给每个.js文件都加上这段话，岂不是美滋滋~\n核心代码：\nconst &#123; ConcatSource &#125; = require('webpack-sources')\n\nclass AddDbugJs &#123;\n  constructor () &#123;&#125;\n\n  apply (compiler) &#123;\n    compiler.hooks.afterCompile.tapAsync(&#123;\n      name: 'AddDbugJs',\n    &#125;, (compilation, callback) => &#123;\n      let assetNames = Object.keys(compilation.assets)\n      for (const name of assetNames) &#123;\n        if (name.endsWith('.js')) &#123;\n          let dbug = `setInterval(() => &#123;(function () &#123;return false;&#125;[\"constructor\"](\"debugger\")[\"call\"]());&#125;, 100);`\n          compilation.updateAsset(\n            name,\n            old => new ConcatSource(old, '\\n', dbug),\n          )\n        &#125;\n      &#125;\n      callback()\n    &#125;)\n  &#125;\n&#125;\n\nmodule.exports = AddDbugJs\n\n\n在项目中使用它：\nconst AddDbugJs = require('add-dbug-js')\nmodule.exports = &#123;\n  devServer: &#123;&#125;,\n  configureWebpack: &#123;\n    plugins:\n      process.env.NODE_ENV !== 'production'\n        ? []\n        : [new AddDbugJs()],\n  &#125;,\n&#125;\n\n这就成了 &#x1F973;\n","categories":["技术分享"],"tags":["Web"]},{"title":"反爬虫机制和破解方法汇总","url":"/2021/08/25/crawl-tips/","content":"说明网络不是法外之地，请大家文明上网\n\n反爬虫机制\n通过UA 识别爬虫有些爬虫的UA很好识别，比如百度，与正常浏览器的UA是不一样的，可以通过识别UA的方法直接封禁此类请求\n\n设置IP的访问频率如果同一个IP超过一定频率，可以通过弹出验证码的方式来过滤机器人（如何巧妙设置验证，也是一个很有意思的问题）\n\n通过并发识别爬虫很多爬虫的并发率是非常高的，当达到一定阈值，可以直接封禁\n\n限制单个 IP/API token的访问量\n\n识别出合法爬虫设置合法爬虫的白名单，例如百度的自动收录等，如果不是合法爬虫则可以直接封禁\n\n蜜罐资源蜜罐资源策略简单来说就是 钓鱼执法 ，通过在页面上设置一些隐式链接，普通用户无法访问，一旦有IP请求了这些资源，则可以判断这些IP是爬虫的IP\n\n\n破解反爬虫机制\n设置下载延迟\n\n禁止cookie很多网站会通过cookie识别用户身份，禁止cookie可以让服务器无法追踪爬虫轨迹\n\n使用UA池每次发送爬虫请求的时候，从UA池里随机使用一个UA\n\n使用IP池每次发送爬虫请求的时候，使用不同的代理IP\n\n分布式爬取\n\n模拟登录\n\n\n","categories":["技术分享"],"tags":["爬虫"]},{"title":"使用Steam作为第三方账号登录你的网站","url":"/2021/08/22/steam/","content":"前言  在日常网络冲浪中，很多网站要求我们注册登录的时候，我们都可以选择使用 QQ|微信|微博|Github 等作为第三方账号去登录。那么如果我的网站都是游戏相关的内容，我可不可以让用户 使用 Steam 作为第三方账号登录 呢？\n问题分析基于网页浏览器的 OpenID 验证如 OpenID 2.0（了解更多） 规范所描述，Steam 只是一个 OpenID 的提供者。在网页浏览器内，第三方网站可以使用 OpenID 来获取用户的 SteamID ，用户的 SteamID 可以用来作为第三方网站的登录凭据（登录）或者与第三方网站的既有账户绑定（注册）。\n流程描述当用户希望登录第三方网站并且将自己的账号与 Steam 账号绑定，第三方网站将用户重定向到 Steam 社区的登录授权页面，用户输入 Steam 的登录凭证后，浏览器自动重定向回第三方网站，并将一些额外的 OpenID 数据写入返回的 URL 中。这些数据通过验证之后即可解析出用户的 SteamID 。\n具体操作申请一个用来校验信息的 ApiKey到这里申请 =&gt; steamcommunity\n构造用来登录的链接参数说明：\nsteamLoginUrl: https://steamcommunity.com/openid/login\nreturnUrl: Steam社区登录之后重定向的链接，一般为登录之后的网站首页 https://xxx.com\nrealm: steam社区授权页面显示的第三方网站名称\n\n// 返回的链接\nconst url = `$&#123;steamLoginUrl&#125;?openid.ns=http://specs.openid.net/auth/2.0&amp;openid.mode=checkid_setup&amp;openid.return_to=$&#123;returnUrl&#125;&amp;openid.realm=$&#123;realm&#125;&amp;openid.identity=http://specs.openid.net/auth/2.0/identifier_select&amp;openid.claimed_id=http://specs.openid.net/auth/2.0/identifier_select`;\n\n当用户点击网页上的 Steam 登录标识的时候，浏览器将用户重定向到 url ，在用户授权之后，会回到 returnUrl 页面。\n校验Steam返回的数据当 Steam 成功授权登录返回到我们的 returnUrl 页面之后，页面链接中会带有很多额外信息：\nconst respUrl = `$&#123;returnUrl&#125;?openid.ns=http://specs.openid.net/auth/2.0&amp;openid.mode=id_res&amp;openid.op_endpoint=https://steamcommunity.com/openid/login&amp;openid.claimed_id=https://steamcommunity.com/openid/id/xxxxxxxxxxx&amp;openid.identity=https://steamcommunity.com/openid/id/xxxxxxxxxxx&amp;openid.return_to=https:/%mywebsite.com&amp;openid.response_nonce=2020-08-27T04:44:16Zs4DPZce8qc+iPCe8JgQKB0BiIDI=&amp;openid.assoc_handle=1234567890&amp;openid.signed=signed,op_endpoint,claimed_id,identity,return_to,response_nonce,assoc_handle&amp;openid.sig=W0u5DRbtHE1GG0ZKXjerUZDUGmc=`;\n\n\n具体的参数说明可参考steam官方文档\n因为返回的参数中带有用户的 SteamID 字段，为了保证信息安全，我们需要对数据进行正确性校验。定义 params = respUrl ? 后面的内容\n\n替换 params 中的 openid.mode=id_res 为 openid.mode=check_authentication\n\n构造校验链接\n const validateUrl = `https://steamcommunity.com/openid/login?$&#123;params&#125;`;\n通过 GET 请求 validateUrl 得到校验结果 得到一个 text/plain 类型的response：\n ns:http://specs.openid.net/auth/2.0\nis_valid:true\n\n is_valid:true 表明校验通过。\n\n\n通过用户的SteamID来获取用户的个人信息当校验完用户的 Steam 登录之后，我们便可以在返回的数据中获取到用户的 SteamID 。\n`openid.identity=https://steamcommunity.com/openid/id/xxxxxxxxxxx(此处则是用户的SteamID)`\n\n通过 Steam 平台开放接口，我们则可以获取到用户的 Steam 个人信息。\nGET 请求：\n  `https://api.steampowered.com/ISteamUser/GetPlayerSummaries/v2/?key=$&#123;开篇申请的ApiKey&#125;&amp;steamids=$&#123;用户的SteamID&#125;`\n\n返回的数据格式：\n\"response\":&#123;  \n  \"players\":[  \n     &#123;  \n        \"steamid\":\"xxxxxxxxxxx\",\n        \"communityvisibilitystate\":1,\n        \"profilestate\":1,\n        \"personaname\":\"xxxx\",\n        \"lastlogoff\":1556305001,\n        \"profileurl\":\"https://steamcommunity.com/profiles/xxxxxxxxxxx/\",\n        \"avatar\":\"https://steamcdn-a.akamaihd.net/steamcommunity/public/images/avatars/32/xxxxxxxxxxx.jpg\",\n        \"avatarmedium\":\"https://steamcdn-a.akamaihd.net/steamcommunity/public/images/avatars/32/xxxxxxxxxxx.jpg\",\n        \"avatarfull\":\"https://steamcdn-a.akamaihd.net/steamcommunity/public/images/avatars/32/xxxxxxxxxxx.jpg\",\n     &#125;\n  ]\n&#125;\n\n至此，使用 Steam 作为网站的第三方账号登录并且获取用户的 Steam 信息就已经全部完成。\n结语 &amp; 一些小问题\n为保证数据安全性，ApiKey 应该存储在网站自己的服务器上，所有的构造链接以及校验过程都应该放在后端完成。\n\nSteam 社区登录的时候偶尔可能需要用户科学上网，一旦用户不能正常访问 Steam 的登录功能，页面要做好容错处理。\n\n\n","categories":["技术分享"],"tags":["Web","BackEnd","Steam"]},{"title":"音乐格式转换","url":"/2021/08/19/music/","content":"为什么需要我们常见的音乐格式很多，但是很多时候由于我们的一些特殊需要，必须将音乐转换成mp3格式才可以被使用。本文只是从技术的角度将ncm格式转换成mp3格式。\n注意事项请勿用作商业用途\n\n源代码# -*- coding: utf-8 -*-\nimport binascii\nimport struct\nimport base64\nimport json\nimport os\nfrom Crypto.Cipher import AES\n\ndef dump(file_path):\n    core_key = binascii.a2b_hex(\"687A4852416D736F356B496E62617857\")\n    meta_key = binascii.a2b_hex(\"2331346C6A6B5F215C5D2630553C2728\")\n    unpad = lambda s : s[0:-(s[-1] if type(s[-1]) == int else ord(s[-1]))]\n    f = open(file_path,'rb')\n    header = f.read(8)\n    assert binascii.b2a_hex(header) == b'4354454e4644414d'\n    f.seek(2, 1)\n    key_length = f.read(4)\n    key_length = struct.unpack('&lt;I', bytes(key_length))[0]\n    key_data = f.read(key_length)\n    key_data_array = bytearray(key_data)\n    for i in range (0,len(key_data_array)): key_data_array[i] ^= 0x64\n    key_data = bytes(key_data_array)\n    cryptor = AES.new(core_key, AES.MODE_ECB)\n    key_data = unpad(cryptor.decrypt(key_data))[17:]\n    key_length = len(key_data)\n    key_data = bytearray(key_data)\n    key_box = bytearray(range(256))\n    c = 0\n    last_byte = 0\n    key_offset = 0\n    for i in range(256):\n        swap = key_box[i]\n        c = (swap + last_byte + key_data[key_offset]) &amp; 0xff\n        key_offset += 1\n        if key_offset >= key_length: key_offset = 0\n        key_box[i] = key_box[c]\n        key_box[c] = swap\n        last_byte = c\n    meta_length = f.read(4)\n    meta_length = struct.unpack('&lt;I', bytes(meta_length))[0]\n    meta_data = f.read(meta_length)\n    meta_data_array = bytearray(meta_data)\n    for i in range(0,len(meta_data_array)): meta_data_array[i] ^= 0x63\n    meta_data = bytes(meta_data_array)\n    meta_data = base64.b64decode(meta_data[22:])\n    cryptor = AES.new(meta_key, AES.MODE_ECB)\n    meta_data = unpad(cryptor.decrypt(meta_data)).decode('utf-8')[6:]\n    meta_data = json.loads(meta_data)\n    crc32 = f.read(4)\n    crc32 = struct.unpack('&lt;I', bytes(crc32))[0]\n    f.seek(5, 1)\n    image_size = f.read(4)\n    image_size = struct.unpack('&lt;I', bytes(image_size))[0]\n    image_data = f.read(image_size)\n    file_name = meta_data['musicName'] + '.' + meta_data['format']\n    m = open(os.path.join(os.path.split(file_path)[0],file_name),'wb')\n    chunk = bytearray()\n    while True:\n        chunk = bytearray(f.read(0x8000))\n        chunk_length = len(chunk)\n        if not chunk:\n            break\n        for i in range(1,chunk_length+1):\n            j = i &amp; 0xff;\n            chunk[i-1] ^= key_box[(key_box[j] + key_box[(key_box[j] + j) &amp; 0xff]) &amp; 0xff]\n        m.write(chunk)\n    m.close()\n    f.close()\n\ndef file_name(file_dir):\n    for root, dirs, files in os.walk(file_dir):\n        for file in files:\n            if os.path.splitext(file)[1] == '.ncm':\n                dump(file)\n                print(file)\n\nif __name__ == '__main__':\n    import sys\n    try:\n        print(os.getcwd())\n        file_name(os.getcwd())\n    except:\n        print('fail')\n\n\n运行方式将music.py与ncm格式的音乐文件放在同一个目录下\npython music.py\n","categories":["小轮子"],"tags":["Python","音乐"]},{"title":"Hello World","url":"/2021/08/18/hello-world/","content":"关于我又开始写博客这件事起因大约两个月前，我加入了一个很有活力的创业团队。这两个月里，我作为一面的面试官参与了几次招聘，并且工作模式也从原来的瀑布式开发转成了敏捷式开发。在这个过程中，我愈发意识到良好的语言表达能力在日常生活与工作中的重要性。因此我决定开始通过写文章的方式来提升自己的语言组织能力与表述能力。\n大概会写些什么内容\n日常工作遇到的一些问题，包括但不限于：前端：Vue、Nuxt、js/ts、CSS、Webpack等后端：Node爬虫：Node、Python数据库：MySQL、TypeORM等\n\n一些阅读积累，包括但不限于： 技术型书籍阅读笔记 文学性书籍读后感\n\n造一些小轮子\n\n\n","categories":[],"tags":[]},{"title":"404","url":"/404","content":"\n\n\n  \n  [居家呆猫]-404\n  \n\n\n  \n    .container {\n      width: 100%;\n      height: 100%;\n      position: fixed;\n      top: 0;\n      left: 0;\n      display: flex;\n      flex-direction: column;\n      justify-content: flex-start;\n      align-items: center;\n    }\n    .notfind {\n      width: 80%;\n      height: 80%\n    }\n    .back {\n      margin-top: 20px;\n      font-size: 16px;\n      text-decoration:none;\n      color: #fb7299;\n    }\n  \n  \n    \n     (゜-゜)つロ返回首页\n  \n\n\n","categories":[],"tags":[]},{"title":"About Maria","url":"/about/","content":"who\n&#x1F5A5;&nbsp;&nbsp;喜欢尝试的 「瞎折腾」 工程师\n&#x1F43E;&nbsp;&nbsp;比较喜欢喝三得利无糖乌龙茶\n\nskills\n以前写了很久的前端\n也写一些爬虫\n移动端 | 小程序也可以写一写\n最近开始写后端\n……\n\nlikes\n音乐：摇滚、后朋、金属\n阅读：加缪、里尔克、余华、赫尔曼黑塞、卡尔维诺、博尔赫斯\n电影：希区柯克、库布里克、侯麦、贾樟柯、杨德昌\n技术相关：尤大、轮子哥vczh、TK教主\n\n最近在听的歌 \n","categories":[],"tags":[]}]