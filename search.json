[{"title":"如何让 vue-cli-service 使用指定配置文件进行构建","url":"/2023/07/14/vue-config/","content":"前言在 Vue 项目中，npm script 里通常用 vue-cli-service build 来构建，该命令默认会使用 vue.config.js 作为配置文件但如果我想在一个 Vue 项目中使用多个配置文件来构建不同产物的需求，该如何处理呢？\nvue-cli-service 并没有设计支持使用类似 --config myConfigFile 这样的参数来指定使用其它配置文件，那么还有其它办法么?\nVUE_CLI_SERVICE_CONFIG_PATH查看 源码 发现，vue-cli-service 是支持使用 VUE_CLI_SERVICE_CONFIG_PATH 环境变量来自定义配置文件：\n// vue-cli/packages/@vue/cli-service/lib/Service.js\nloadUserOptions () &#123;\n    let fileConfig, pkgConfig, resolved, resolvedFrom\n    const configPath = (\n      process.env.VUE_CLI_SERVICE_CONFIG_PATH ||\n      path.resolve(this.context, 'vue.config.js')\n    )\n    if (fs.existsSync(configPath)) &#123;\n      try &#123;\n        fileConfig = require(configPath)\n\n        if (typeof fileConfig === 'function') &#123;\n          fileConfig = fileConfig()\n        &#125;\n\n        if (!fileConfig || typeof fileConfig !== 'object') &#123;\n          error(\n            `Error loading $&#123;chalk.bold('vue.config.js')&#125;: should export an object or a function that returns object.`\n          )\n          fileConfig = null\n        &#125;\n      &#125; catch (e) &#123;\n        error(`Error loading $&#123;chalk.bold('vue.config.js')&#125;:`)\n        throw e\n      &#125;\n    &#125;\n  // xxx ...\n&#125;\n\n既然可以通过 VUE_CLI_SERVICE_CONFIG_PATH 来指定，那就比较容易解决了。\n新建 build.js 脚本：\nconst &#123; spawnSync &#125; = require(\"child_process\");\nconst path = require(\"path\");\nconst buildByConfigFile = async (module) =>\n  return spawnSync('npm', ['run', 'build'], &#123;\n    shell: true,\n    env: &#123;\n      ...process.env,\n      VUE_CLI_SERVICE_CONFIG_PATH: path.resolve(\n        __dirname,\n        `vue.config.$&#123;module&#125;.js`\n      ),\n    &#125;,\n    stdio: 'inherit',\n  &#125;);\n&#125;;\n\nconst build = async () => &#123;\nawait buildByConfigFile('module1');\nawait buildByConfigFile('module2');\n&#125;\n\n\n然后新建一个 npm script 内容为: &quot;build:multi&quot;: &quot;node build.js&quot;。\n成了。\n","categories":["技术分享"],"tags":["Web","FrontEnd","Vue"]},{"title":"流式输出的文本进行实时关键词检查","url":"/2023/07/06/sensitive-check/","content":"","categories":["系统设计"],"tags":["系统设计"]},{"title":"支付系统中如何避免单边账","url":"/2023/05/28/single-payment/","content":"什么是单边账？单边账 是指 商家或者用户其中一端造成资损。对于一笔交易，商家端和用户端的结果不一致，分为两种情况：\n\n商家资损：用户实际未付款成功，但商家系统判定支付成功；或用户支付成功后，商家系统由于逻辑问题发起了撤销。\n用户资损：用户付款成功，但商家系统未得到支付成功的结果，误认为付款失败，再次扫用户付款码发起支付，导致用户多支付了一笔。\n\n解决方案\n每一笔交易一定要结束，即要么支付成功，要么撤销交易，一定不能有交易一直停留在等待用户付款的状态。\n轮询+撤销的流程中，如轮询的结果一直为未付款，撤销一定要紧接着最后一次查询，当中不能有时间间隔。\n门店收银系统应该具备独立的手动查询功能作为兜底，输入商家订单号（可从用户手机账单中获得）调用支付宝查询接口获得确切的支付状态。\n当遇到网络超时和未知异常时，参考异常处理流程正确处理，对于每一笔交易或退款，一定要得到确切的结果。\n撤销接口调用成功后，需要在收银台页面为收银员展示撤销成功的强提示文案，且按实际业务情况引导收银员进行手工订单查询。如果撤销接口没有明确返回处理结果，如遇到网络超时或支付宝未知异常等情况，则需要在收银台提示文案中表明，撤销正在处理中；若该笔订单已经支付则后续会有发生退款的可能，并和用户做好线下沟通。\n对于经过轮询和撤销仍然无法确认结果的（例如系统故障或门店断网），应上报总部 IT 或财务，由 IT（从系统内）或财务（从支付宝后台），确认支付结果后，通过后台发起退款。或让用户查询手机支付宝账单，如用户手机没网络，可拨打支付宝客服热线 4007585858 确认支付结果。\n在上述基础上，业务流程培训时应强调支付结果必须以商家端为准，用户手机上的支付宝结果或账单只能做参考，不能作为最终识别标准。如果商家未正确处理业务逻辑和业务流程培训，存在潜在的风险，商家自行承担因此而产生的所有损失。\n\n轮询流程当请求支付返回 WAIT_BUYER_PAY(等待用户支付) 时，收银系统需要做轮询处理，建议：\n\n收银终端界面阻塞并提示 等待用户确认支付。\n轮询间隔设为 3~6 秒，轮询总时长 60 秒左右。\n轮询时，收银终端界面提供手动停止功能，停止时必须调用撤销 API 撤销交易。\n\n","categories":["系统设计"],"tags":["系统设计"]},{"title":"终端根据 .nvmrc 文件自动执行切换 Node 版本","url":"/2023/04/26/nvmrc/","content":"前置知识需要了解一些关于 nvm 的基本知识。\nnvmrc 如何使用创建一个 .nvmrc 文件，文件内容是一个 Node 版本的数字或者其它 nvm 可以理解的文本内容（例如：v14.21.3, 可以在终端输入 nvm --help 查看更多使用方法）。有了 .nvmrc 文件后，我们在终端没有指定 Node 版本时执行 nvm use, nvm install, nvm exec, nvm run, 和 nvm which 命令时会使用 .nvmrc 文件指定的 Node 版本。\nnvm use 等命令将从当前目录向上遍历目录结构寻找文件 .nvmrc。也就是说，在带有 .nvmrc 的目录的任何子目录中运行nvm use 等命令，.nvmrc 都会起作用。\n集成到 shell以 zsh 为例，编辑 .zshrc 文件，添加以下代码：\n\nautoload -U add-zsh-hook\nload-nvmrc() &#123;\n  local nvmrc_path=\"$(nvm_find_nvmrc)\"\n\n  if [ -n \"$nvmrc_path\" ]; then\n    local nvmrc_node_version=$(nvm version \"$(cat \"$&#123;nvmrc_path&#125;\")\")\n\n    if [ \"$nvmrc_node_version\" = \"N/A\" ]; then\n      nvm install\n    elif [ \"$nvmrc_node_version\" != \"$(nvm version)\" ]; then\n      nvm use\n    fi\n  elif [ -n \"$(PWD=$OLDPWD nvm_find_nvmrc)\" ] &amp;&amp; [ \"$(nvm version)\" != \"$(nvm version default)\" ]; then\n    echo \"Reverting to nvm default version\"\n    nvm use default\n  fi\n&#125;\nadd-zsh-hook chpwd load-nvmrc\nload-nvmrc\n\n\n编辑保存之后，执行 source ~/.zshrc 使内容生效。此时，在有 .nvmrc 文件项目打开终端，会发现已经自动运行 nvm use：\n$ j test\n/Users/Maria/Desktop/test/\nFound '/Users/Maria/Desktop/test/.nvmrc' with version &lt;v14.21.3>\nNow using node v14.21.3 (npm v6.14.18)\n\n如果没有找到 .nvmrc，会切换到 system default 的 Node 版本：\n$ j desk\n/Users/Maria/Desktop\nReverting to nvm default version\nNow using node v20.0.0 (npm v9.6.4)\n\n注意\n.nvmrc 文件必须是一个 &lt;version&gt; 符合 nvm --help 所列出的，版本号后跟换行符，不允许尾随空格\n\n","categories":["技术分享"],"tags":[]},{"title":"tsconfig.json 配置详解","url":"/2023/03/19/tsconfig.json%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/","content":"compilerOptions 编译选项target 用于指定编译之后的版本目录\n\"target\": \"es5\",\n\nmodule 用来指定要使用的模板标准\n\"module\": \"commonjs\",\n\nlib 用于指定要包含在编译中的库文件\n\"lib\":[\n    \"es6\",\n    \"dom\"\n],\n\nallowJs 用来指定是否允许编译 JS 文件，默认 false,即不编译 JS 文件\n\"allowJs\": true,\n\ncheckJs 用来指定是否检查和报告 JS 文件中的错误，默认 false\n\"checkJs\": true,\n\n指定 jsx 代码用于的开发环境:’preserve’,’react-native’,or ‘react’\n\"jsx\": \"preserve\",\n\ndeclaration 用来指定是否在编译的时候生成相的 d.ts 声明文件，如果设为 true,编译每个 ts 文件之后会生成一个 js 文件和一个声明文件，但是 declaration 和 allowJs 不能同时设为 true\n\"declaration\": true,\n\ndeclarationMap 用来指定编译时是否生成.map 文件\n\"declarationMap\": true,\n\nsourceMap 用来指定编译时是否生成.map 文件\n\"sourceMap\": true,\n\noutFile 用于指定输出文件合并为一个文件，只有设置 module 的值为 amd 和 system 模块时才支持这个配置\n\"outFile\": \"./\",\n\noutDir 用来指定输出文件夹，值为一个文件夹路径字符串，输出的文件都将放置在这个文件夹\n\"outDir\": \"./\",\n\nrootDir 用来指定编译文件的根目录，编译器会在根目录查找入口文件\n\"rootDir\": \"./\",\n\ncomposite 是否编译构建引用项目\n\"composite\": true,\n\nremoveComments 用于指定是否将编译后的文件注释删掉，设为 true 的话即删除注释，默认为 false\n\"removeComments\": true,\n\nnoEmit 不生成编译文件\n\"noEmit\": true,\n\nimportHelpers 指定是否引入 tslib 里的复制工具函数，默认为 false\n\"importHelpers\": true,\n\n当 target 为”ES5”或”ES3”时，为”for-of” “spread”和”destructuring”中的迭代器提供完全支持\n\"downlevelIteration\": true,\n\nisolatedModules 指定是否将每个文件作为单独的模块，默认为 true，他不可以和 declaration 同时设定\n\"isolatedModules\": true,\n\nstrict 用于指定是否启动所有类型检查，如果设为 true 这回同时开启下面这几个严格检查，默认为 false\n\"strict\": true,\n\nnoImplicitAny 如果我们没有一些值设置明确类型，编译器会默认认为这个值为 any 类型，如果将 noImplicitAny 设为 true,则如果没有设置明确的类型会报错，默认值为 false\n\"noImplicitAny\": true,\n\nstrictNullChecks 当设为 true 时，null 和 undefined 值不能赋值给非这两种类型的值，别的类型的值也不能赋给他们，除了 any 类型，还有个例外就是 undefined 可以赋值给 void 类型\n\"strictNullChecks\": true,\n\nstrictFunctionTypes 用来指定是否使用函数参数双向协变检查\n\"strictFunctionTypes\": true,\n\nstrictBindCallApply 设为 true 后对 bind、call 和 apply 绑定的方法的参数的检测是严格检测\n\"strictBindCallApply\": true,\n\nstrictPropertyInitialization 设为 true 后会检查类的非 undefined 属性是否已经在构造函数里初始化，如果要开启这项，需要同时开启 strictNullChecks,默认为 false\n\"strictPropertyInitialization\": true,\n\n当 this 表达式的值为 any 类型的时候，生成一个错误\n\"noImplicitThis\": true,\n\nalwaysStrict 指定始终以严格模式检查每个模块，并且在编译之后的 JS 文件中加入”use strict”字符串，用来告诉浏览器该 JS 为严格模式\n\"alwaysStrict\": true,\n\nnoUnusedLocals 用于检查是否有定义了但是没有使用变量，对于这一点的检测，使用 ESLint 可以在你书写代码的时候做提示，你可以配合使用，他的默认值为 false\n\"noUnusedLocals\": true,\n\nnoUnusedParameters 用于检测是否在函数中没有使用的参数\n\"noUnusedParameters\": true,\n\nnoImplicitReturns 用于检查函数是否有返回值，设为 true 后，如果函数没有返回值则会提示，默认为 false\n\"noImplicitReturns\": true,\n\nnoFallthroughCasesInSwitch 用于检查 switch 中是否有 case 没有使用 break 跳出 switch,默认为 false\n\"noFallthroughCasesInSwitch\": true,\n\nmoduleResolution 用于选择模块解析策略，有”node”和”classic”两种类型\n\"moduleResolution\": \"node\",\n\nbaseUrl 用于设置解析非相对模块名称的基本目录，相对模块不会受到 baseUrl 的影响\n\"baseUrl\": \"./\",\n\npaths 用于设置模块名到基于 baseUrl 的路径映射\n\"paths\": &#123;\n    \"_\":[\"./node_modules/@types\", \"./typings/_\"]\n&#125;,\n\nrootDirs 可以指定一个路径列表，在构建时编译器会将这个路径中的内容都放到一个文件夹中\n\"rootDirs\": [],\n\ntypeRoots 用来指定声明文件或文件夹的路径列表，如果指定了此项，则只有在这里列出的声明文件才会被加载\n\"typeRoots\": [],\n\ntypes 用于指定需要包含的模块，只有在这里列出的模块的声明文件才会被加载\n\"types\": [],\n\nallowSyntheticDefaultImports 用来指定允许从没有默认导出的模块中默认导入\n\"allowSyntheticDefaultImports\": true,\n\nesModuleInterop 通过导入内容创建命名空间，实现 CommonJS 和 ES 模块之间的互操作性\n\"esModuleInterop\": true,\n\n不把符号链接解析为真实路径，具体可以了解下 webpack 和 node.js 的 symlink 相关知识\n\"preserveSymlinks\": true,\n\nsourceRoot 用于指定调试器应该找到 TypeScript 文件而不是源文件的位置，这个值会被写进.map 文件里\n\"sourceRoot\": \"\",\n\nmapRoot 用于指定调试器找到映射文件而非生成文件的位置，指定 map 文件的根路径，该选项会影响.map 文件中的 sources 属性\n\"mapRoot\": \"\",\n\ninlineSourceMap 指定是否将 map 文件内容和 js 文件编译在一个同一个 js 文件中，如果设为 true,则 map 的内容会以 //#sourceMappingURL= 开头，然后接 base64 字符串的形式插入在 js 文件底部\n\"inlineSourceMap\": true,\n\ninlineSources 用于指定是否进一步将 ts 文件的内容也包含到输出文件中\n\"inlineSources\": true,\n\nexperimentalDecorators 用于指定是否启用实验性的装饰器特性\n\"experimentalDecorators\": true,\n\nemitDecoratorMetadata 用于指定是否为装上去提供元数据支持，关于元数据，也是 ES6 的新标准，可以通过 Reflect 提供的静态方法获取元数据，如果需要使用 Reflect 的一些方法，需要引用 ES2015.Reflect 这个库\n\"emitDecoratorMetadata\": true,\n\ncompileOnSavecompileOnSave 如果设为 true,在我们编辑了项目文件保存的时候，编辑器会根据 tsconfig.json 的配置更新重新生成文本，不过这个编辑器支持\n\"compileOnSave\": true,\n\nincludeinclude 也可以指定要编译的路径列表\n\"include\": [],\n\nfilesfiles 可以配置一个数组列表\n\"files\": [],\n\nexcludeexclude 表示要排除的，不编译的文件，它也可以指定一个列表，规则和 include 一样，可以是文件可以是文件夹，可以是相对路径或绝对路径，可以使用通配符\n\"exclude\": [],\n\nextendsextends 可以通过指定一个其他的 tsconfig.json 文件路径，来继承这个配置文件里的配置，继承来的文件的配置会覆盖当前文件定义的配置\n\"extends\": \"\",\n\nreferences一个对象数组，指定要引用的项目\n\"references\": [],\n","categories":["技术分享"],"tags":["typescript"]},{"title":"ReferenceError primordials is not defined","url":"/2023/03/03/primordials-is-not-defined/","content":"前言在维护远古项目的时候，当执行完npm run dev的时候出现了个 ReferenceError: primordials is not defined 错误，查看发现是 node 版本和 gulp 版本不兼容导致的，由于只是【维护一下】，因此排除将它们都升级的方案。\n解决方案shrinkwrap在 package.json 文件的同级目录下新建一个 npm-shrinkwrap.json 文件\n&#123;\n  \"dependencies\": &#123;\n    \"graceful-fs\": &#123;\n      \"version\": \"4.2.3\"\n    &#125;\n  &#125;\n&#125;\n\n然后删除 node_modules，再重新 npm install 即可。\n这个文件在执行过一次 npm install 以后，下次再执行就没有效果了！\nresolutions在 package.json 文件里加入以下代码:\n&#123;\n  // current package.json\n  \"scripts\": &#123;\n    // current package.json scripts\n    \"preinstall\": \"npx npm-force-resolutions\"\n  &#125;,\n  \"resolutions\": &#123;\n    \"graceful-fs\": \"4.2.3\"\n  &#125;\n&#125;\n\nnpm-force-resolutions 会更改 package-lock.json 文件来设置 graceful-fs 到想要的版本。这个方法每次执行 npm install 都会生效。\n","categories":["Bugs 小记"],"tags":[]},{"title":"Linux 使用 rsync 快速删除大量文件","url":"/2023/02/26/linux-rsync/","content":"前言很早之前在服务器上部署过一个微前端的项目，由于复杂度比较高导致 node_modules 过于庞大，当执行 rm -rf node_modules/ 之后发现有一个报错：\nargument list too long\n\n查询了一下发现原因是：删除文件中包含的小文件数量过多，受到 shell 参数个数限制，不能正常删除。后面找了方案，发现可以通过 rsync 去快速删除大量文件。\n省流版# 以删除 logs 文件夹为例\n# 创建一个空文件夹\nmkdir -p /xxx/empty;\n# 执行 rsync 同步空文件夹\nrsync --delete-before -aO  /xxx/empty/ /xxx/logs/;\n\n详细版Linux 文件存储原理Linux 文件存储数据是放在一张 inode 表，里面每一个文件的节点，每个节点包括以下内容：\n\n文件类型\n权限\nUID，GID\ni_nlink 链接数（指向这个文件名路径名称个数）\ni_count 使用数（指使用这个文件的进程数）\n该文件的大小和不同的时间戳\n指向磁盘上文件的数据块指针\n有关文件的其他数据\n\nLinux 文件真正删除的过程：\ni_nlink=0 没有人进行链接使用，包括任何硬链接\ni_count=0 没有任何进程使用\n\nrm 原理减少磁盘引用计数 i_nlink，就是减少其他文件对这个文件链接，实际并没有删除文件内容。如果想要真正删除一个文件，还需要同时将 i_count 降至 0。\nrsync 原理rsync 本身是将两个文件夹作同步使用，使用 rsync 删除文件，步骤就是将一个空文件夹同步到要删除的文件夹里，这样就等于将文件夹清空了 :)\n","categories":["技术分享"],"tags":["Linux"]},{"title":"微信小程序合理使用 setData()","url":"/2022/12/04/mp-setdata/","content":"前言setData 是微信小程序开发中使用最频繁、也是最容易引发性能问题的接口。\nsetData 的流程\n逻辑层虚拟 DOM 树的遍历和更新，触发组件生命周期和 observer 等\n将 data 从逻辑层传输到视图层\n视图层虚拟 DOM 树的更新、真实 DOM 元素的更新并触发页面渲染更新\n\n数据通信由于小程序的逻辑层和视图层是两个独立的运行环境、分属不同的线程或进程，不能直接进行数据共享，需要进行数据的序列化、跨线程/进程的数据传输、数据的反序列化，因此 **数据传输过程是异步的、非实时的**。数据传输的耗时与数据量的大小正相关，如果对端线程处于繁忙状态，数据会在消息队列中等待。\n使用优化data 应只包括渲染相关的数据setData() 应只用来进行渲染相关的数据更新。用 setData 的方式更新渲染无关的字段，会触发额外的渲染流程，或者增加传输的数据量，影响渲染耗时。页面或组件渲染无关的数据，应挂在非 data 的字段下，如 this.userData = &#123;userId: &#39;xxx&#39;&#125;;\n控制 setData() 的频率每次 setData() 都会触发逻辑层虚拟 DOM 树的遍历和更新，也可能会导致触发一次完整的页面渲染流程。过于频繁（毫秒级）的调用 setData()，会导致以下后果：\n\n逻辑层 JS 线程持续繁忙，无法正常响应用户操作的事件，也无法正常完成页面切换\n视图层 JS 线程持续处于忙碌状态，逻辑层 -&gt; 视图层通信耗时上升，视图层收到消息的延时较高，渲染出现明显延迟\n视图层无法及时响应用户操作，用户滑动页面时感到明显卡顿，操作反馈延迟，用户操作事件无法及时传递到逻辑层，逻辑层亦无法及时将操作处理结果及时传递到视图层\n\n因遵守以下规则：\n\n✅ 仅在需要进行页面内容更新时调用 setData()\n✅ 对连续的 setData() 调用尽可能的进行合并\n❌ 避免不必要的 setData\n❌ 避免以过高的频率持续调用 setData()，例如毫秒级的倒计时\n❌ 避免在 onPageScroll 回调中每次都调用 setData()\n\n选择合适的 setData() 范围组件的 setData() 只会引起当前组件和子组件的更新，可以降低虚拟 DOM 更新时的计算开销。对于需要频繁更新的页面元素（例如：秒杀倒计时），可以封装为独立的组件，在组件内进行 setData() 操作。\nsetData() 应只传发生变化的数据setData() 的数据量会影响数据拷贝和数据通讯的耗时，增加页面更新的开销，造成页面更新延迟。应该以数据路径形式改变数组中的某一项或对象的某个属性，而不是每次都更新整个对象或数组。\n控制 后台态 页面的 setData()由于小程序逻辑层是单线程运行的，后台态页面去 setData() 也会抢占前台页面的运行资源，且后台态页面的的渲染用户是无法感知的，会产生浪费。在某些平台上，小程序渲染层各 WebView 也是共享同一个线程，后台页面的渲染和逻辑执行也会导致前台页面的卡顿。\n","categories":["技术分享"],"tags":["微信小程序"]},{"title":"微信小程序修改数组/对象里的值","url":"/2022/12/03/mp-data-change/","content":"参考：Page.prototype.setData(Object data, Function callback)\n// example:\ntoggleOpen(e) &#123;\n  const &#123; pid &#125; = e.target.dataset;\n  for (let i = 0; i &lt; this.data.places.length; i++) &#123;\n    if (pid == this.data.places[i]._id) &#123;\n      let label = `places[$&#123;i&#125;].open`;\n      let value = !this.data.places[i].open;\n      this.setData(&#123;\n        [label]: value,\n      &#125;);\n      break;\n    &#125;\n  &#125;\n&#125;\n\n当需要修改的内容是数组或者对象的时候，可以通过构造 key 的方式来修改。\nlet label = `places[$&#123;i&#125;].open`;\nlet value = !this.data.places[i].open;\nthis.setData(&#123;\n  [label]: value,\n&#125;);\n","categories":["Bugs 小记"],"tags":["微信小程序"]},{"title":"如何修改 Git 的提交作者信息","url":"/2022/11/28/git-reset-author/","content":"对于最近的提交更改最近提交的作者信息：\ngit commit --amend --author=\"author_name &lt;author_email> --no-edit\"\n\nauthor_email 必须加上&lt;&gt;\n如果作者已经在 .git/config 中配置好，也可以直接运行：\ngit commit --amend --reset-author --no-edit\n\n对于较旧的提交如果想更改多个提交的作者信息，我们可以使用 git rebase.例如：假设有提交记录为 A-&gt;B-&gt;C-&gt;D-&gt;E, 想要更改提交 B 和 D 的作者。\n\n运行变基命令 git rebase -i A\n将打开一个 vim 窗口打，可以看到 B、C、D、E 的提交哈希列表，它们之前都有 pick\n将 B 和 D 之前的 pick 改成 ,\n保存并退出 vim 窗口 (:wq)\n运行 git commit --amend --author=&quot;author_name &lt;author-email&gt;&quot; --no-edit（这是针对提交 B 的）\n运行 git rebase --continue 以继续变基\n运行 git commit --amend --author=&quot;author_name &lt;author-email&gt;&quot; --no-edit（这次是提交 D）\n运行 git rebase --continue 以继续变基\n\n变基过程结束。\n对于一系列提交如果想将作者信息从较旧的提交更改为最近的提交，有一种比之前更有效/更快的方法：\n# Note that to also include the root commit, we need to add --root option\ngit rebase --interactive --exec \"git commit --amend --reset-author --no-edit\" &#123;commit-ref&#125;\n\n将会打开一个 vim 窗口：\npick xxx\nexec git commit --amend --reset-author --no-edit\npick xxx\nexec git commit --amend --reset-author --no-edit\n...\n\n保存退出窗口（:wq）。这些提交的作者信息将自动更改。\n请注意：更改提交作者信息将更改此提交的提交哈希，并且还会更改该特定提交后的提交哈希。因此，如果已将这些提交推送到远程仓库，则本地提交将与远程不同。\n","categories":["技术分享"],"tags":["工具","Git"]},{"title":"Vue3 Tree-shaking","url":"/2022/11/17/Vue3%20Tree-shaking/","content":"是什么Tree-shaking 是一种通过清除多余代码来优化项目打包体积的技术，专业术语为：Dead code elimination.\n简单来说就是在保持代码运行结果不变的前提下去除无用的代码。\n在 Vue2 中，无论我们使用什么功能，它们最终都会出现在打包产物中，主要原因是 Vue 实例在项目中是单例的，程序无法检测到该实例对象的哪些属性在代码中会被使用到。\n而 Vue3 引入 Tree-shaking 特性，将全局 api 进行分块，如果某些功能不被使用到，那么它们将不会出现在打包产物中。\n如何做Tree-shaking 是基于 ES6 模板语法（import 和 exports），主要借助 ES6 模块的静态编译思想，在编译的时候就能确定模块之间的依赖关系，以及输入和输出的变量。\nTree-shaking 一共做了两件事：\n\n编译阶段利用 ES6 Moudle 判断哪些模块已经加载\n判断哪些模块和变量未被使用 / 引用，进而删除\n\n作用通过 Tree-shaking，Vue3 的好处有：\n\n减少程序的体积（更小）\n减少程序运行时间（更快）\n便于对程序架构进行优化（更友好）\n\n","categories":["技术分享"],"tags":["Web","FrontEnd","Vue"]},{"title":"GitHub 加速教程","url":"/2022/10/28/github-speed/","content":"前言使用 GitHub 的时候，经常会出现网络连接不稳定的情况，偏偏很着急的时候就非常耽误事儿。所以就想着有没有什么办法能尽可能保证访问 GitHub 的连通性。\n一般解决加速问题，最常用的手段就是使用 http proxy, 但是大部分的 GitHub 用户都会使用 SSH keys.\n设置 Http Proxygit config --global http.proxy socks5://127.0.0.1:7890\n\n因为 git 底层使用 libcurl 发送 http 请求，而 libcurl 的代理使用 socks5:// 时会在本地解析 DNS，实际使用中我们希望 DNS 也在远程解析，所以使用 socks5h ，即\ngit config --global http.proxy socks5h://127.0.0.1:7890\n\n推荐使用 socks5 代理，因为 socks5 包含 http(s)。而且 socks5 代理工作在 osi 七层模型中的会话层（第五层），https/http 代理工作在 osi 七层模型的应用层（第七层）, socks 代理更加底层。所以就没必要配置 git config --global http.proxy http://127.0.0.1:7890 了。\n但这样配置的话会使本机所有的 git 服务都走了代理，假如你在良心云上部署了自己的 gitea，服务地址 https://gitea.example.com，那么可以只配置 GitHub 的 http proxy，即\ngit config --global http.https://github.com.proxy socks5://127.0.0.1:7890\n\n这样做实际上是修改了 ~/.gitconfig 文件，添加了如下内容\n[http \"https://github.com\"]\n  proxy = socks5://127.0.0.1:7890\n\n设置 SSH Proxy配置文件在用户家目录下的 .ssh/config 其中 nc 程序位于 /usr/bin/nc\n$ cat ~/.ssh/config\n\nHost github.com\n Hostname ssh.github.com\n IdentityFile /xxx/.ssh/github_id_rsa\n User git\n Port 443\n ProxyCommand nc -v -x 127.0.0.1:7890 %h %p\n\n说明\n为什么 hostname 是 ssh.github.com，为什么要用 443 端口，ssh 默认不是 22 端口么？因为有些 T 子 对于 22 端口做了限制，要么禁止了，要么有些抽风，这时经常会遇到如下错误：\nkex_exchange_identification: Connection closed by remote host\n\n所以如果 22 端口不畅就使用 443，安全稳定可靠。(ps: 22 端口时 hostname 请填 github.com。\n\n如果代理设置了用户名和密码基础认证呢？比如 clash 的 config.yaml 中就可以添加如下配置以增加 http 基础认证\n\n\nauthentication:\n  - \"USERNAME:PASSWORD\"\n","categories":["小轮子"],"tags":["工具","Git"]},{"title":"【耳朵会说话-04】《混乱之子》 - 苏紫旭 & The Paramecia","url":"/2022/09/13/music-04/","content":"\n\n作词 : 苏紫旭&amp;The Paramecia\n作曲 : 苏紫旭&amp;The Paramecia\n词曲Songwriting：苏紫旭\n演唱Vocals：苏紫旭\n十二弦吉他 12Strings guitar：苏紫旭\n小提琴Violin:Toby Sheer\n电吉他 Electric Guitar：翁曲弦\n爵士鼓Drums：孙钰\n贝斯Bass：钟洋\n编曲Arrangement：苏紫旭\n混音师Mixing：钟洋\n录音棚Recording Studio：Soma Studio\n母带工程Master：Zachary Dorne&amp;Khandha Rooms\n制作人Producer：苏紫旭\n封面设计Art work：Yingwei Tang\n歌词翻译Translation：小易（Joshua Tufano）\n\n他推开窗想着要不离开家要不一跃而下\nHe pushes the window open wide. Thinking either he’ll leave home. Or he’ll just jump\n窗外车水马龙告诉你必须顺从必须听时代的话\nOutside the swimming siren streets call out to you. Compelling you to bend to the language of the times\n赢家制定了规则，好让赢的一直赢输的一直输\nThe winners make the rules. The winners always win. The losers always lose\n有人在挨饿受苦，有人在舒适中麻木\nSomeone is starving and suffering at this moment.Someone’s comfortably numb\n\n\n他听从路的召唤\nHe heeded the call of the road\n变成风变成雪变成他不是的一切\nBecoming wind, becoming snow, becoming everything he was not\n游荡在城市中，“这儿有你想要的生活，去做个诗人战士革命者”\nDrifting through the city, “Here’s the life you wanted:To be a poet, a warrior, a revolutionary”\n他学会了交易学会了隐藏自己\nHe learned to do business. How to conceal his self\n变得聪明透顶，无论谁都得不到他的心\nHe wised up, through and through, None could obtain his true heart\n可总有声音回响“你是否得到了你想要的？\nBut there was always a voice ringing “Did you get what you wanted?”\n\n\n他在情欲的烟雾中上升坠落，他在悬崖边保持着平衡\nHe rose in the smoke of lust and came crashing back down. He kept his balance on the edge of the cliff\n暴风中的睡眠，被遗忘的信，他从死亡的刀锋上，尝到了温度\nSleeping in the eye of the storm. A forgotten letter there. He tasted the temperature on the blade of death\n花的残骸，破碎的歌，他像沙一样卷起，他被身体掌控\nThe ruins of a flower. A broken song. He swirled up like sand. Controlled by the body\n他蒙住双眼，他执意向前，寻找着王座。\nBlindfolding himself. Insistently pushing onward.In search of the throne\n\n\n他回到来时的街道，孩子们坐在地上说“我们有狂热的思想”\nHe returned to the street he started off from. Children gathered, set on the ground. Saying, “We’ve got hot ideas”\n他看着眼前的混乱，却不愿再做其中的浪花一瓣\nHe peered into the chaos before his eyes. Unwilling to again become yet another petal amongst the white garland tip waves\n他走进黑夜，如同置身旷野\nHe walked straight into the black night, Feeling he’s like he’s back in the wild\n再一次他孑然一身，再一次他孤身一人。\nOnce again, he’s all on his own. Once again, he’s got nowhere else to go\n可总有声音回响“你是否得到了你想要的？”\nBut there’s always a voice ringing “Did you get what it was that you wanted?”\n","categories":["耳朵会说话"],"tags":["音乐"]},{"title":"“激情和创造力，而不是工作时长”","url":"/2022/09/13/work-time/","content":"谈到工作谈到工作，大致也就那么几类：\n\n生活所迫\n为了理想\n真的感兴趣…\n\n大多数都停在 1，而我庆幸的是最初 写代码 不是为了工作，所以到现在为止，我还有一丝丝对 3 的幻想。\n可是，在职场时间久了，也会对工作有一些所谓的 犯恶心，对兴趣的幻想也几经磨灭，剩下的逐渐被按部就班所代替。\n也经常问自己：为什么呢?\n那些日子不再有最开始写的代码是一段 shell，自动关机的脚本，保存成 .bat 文件后发给正一起上 信息课 的同班同学，骗他双击一下，然后听他惊慌失措的声音。那个时候的我以为技术是炫酷的，是一种与众不同的手段，是小把戏成功之后的洋洋得意，是自我满足，是下课之后也不舍离开机房的频频回眸。\n我没有办法永远停留在中学时代，但我经常会想起那个时候我充满激情，永远也不会觉得累。\n创造力后来我如愿以偿读了计算机专业，我还在一直写，写我感兴趣的一切。为了参加设计比赛可以通宵写代码，为了刷排名，连续好多个周末都在图书馆 OC，想出一个更优解就可以激动一整天。那个时候我脑子里天马行空，对事物总有千奇百怪的想法。\n但是我工作了我开始被迫意识到：技术服务于业务，技术只是工具，写代码需要考虑投入产出比，没需求不要创造需求...。\n所有人都在提倡效率第一，以结果为导向，但是这好像也没问题。\n为了业务上线，我偶尔也会通宵加班，过去一年中也有过几次赶着早高峰的地铁下班，我还在热爱着 写点代码。\n但是，总有些老板喜欢把员工的利益和公司的发展放在对立面，也不仅仅是老板，有些员工也会自己走到对立面去。老板想员工多干点活，员工想着又不加工资我为什么要额外付出，于是经常能看见很大一批人，他们喜欢上班摸鱼，有老板 经过 的时候就开始奋力工作，为了让大家知道他很辛苦，宁愿在工位听听歌也要等到老板走后才下班。\n有些人内卷，只是在卷时间而已。\n激情和创造力才是共同进步当充满激情的时候，人们更愿意承担责任。老板想要员工都有创业精神，可是创业精神不是每天守着工作死盯不放，程序员这个行业，更需要我们能拥有的是创造力。\n我只能写下来自省：多要求自己保持激情和创造力，而不是和 他们 一起卷工作时间。\n","categories":["软件开发随想录"],"tags":[]},{"title":"如何判断一个 url 是否是图片呢？","url":"/2022/09/05/url-is-image-or-not/","content":"前言在 daily coding 的时候经常会有这种需求:\nif url 是图片，则 A;\nelse B.\n\n那么，如何判断一个 url 是否是图片呢？\n进入正题正则通过判断 url 的结尾扩展名：\nfunction isImgUrl(url) &#123;\n  return /\\.(jpg|jpeg|png|webp|avif|gif)$/.test(url);\n&#125;\n\n诚然，这种方式只要枚举出所有的图片扩展名，就可以校验出是否是图片。\n但是我们也经常会遇到一些图片，**_压根没有扩展名_**\n比如我的 github 头像：https://avatars.githubusercontent.com/u/19246724?v=4\n利用 &lt;img&gt; 的 onload 事件将 url 赋值给 img 的 src 属性，如果可以出发 img 的 onload 方法，则 url 为图片。\n但是，这种方法浏览器会下载整个图片，造成不必要的资源浪费。\n发送 HEAD 请求只检查 MIME发送 HEAD 请求，根据 response.headers 中的 Content-Type 来判断。\nfunction isImgUrl(url) &#123;\n  return fetch(url, &#123; method: \"HEAD\" &#125;).then((res) => &#123;\n    return res.headers.get(\"Content-Type\").startsWith(\"image\");\n  &#125;);\n&#125;\n\n不同的图像都是以 image MIME 类型开头，比如 jpge 是 image/jpeg，png 是 image/png 等。这样，不用担心响应请求的开销，就可以知道 url 是否是图片。\n结尾虽然这种通过校验 MIME 的方法可以校验是否是图片，但是由于发送请求的缘故，当 CORS 被拦截的时候，它就不灵了 &#x1F622;\n","categories":["技术分享"],"tags":["Web","FrontEnd","JS"]},{"title":"计算图片的平均色值(主色调)与补色","url":"/2022/09/01/img-color/","content":"前言前端开发的时候经常会有一些奇奇怪怪的需求，比如：\n\nUI 设计师希望某个详情页的背景色是图片的平均颜色\n图片上加文字，文字的颜色是图片的补色\n…\n\n虽然这些东西听起来就很想骂人，但是没办法，还是 要吃饭啊\n思路\n平均色值第一反应就是比较粗暴的方法，统计所有像素点的 r,g,b 的值，然后分别用累加的 r,g,b 的值除以像素点的个数，得到一个 平均的 r,g,b\n\n补色得到 平均 r,g,b 之后，再用 255 减去对应的值，就可以得到补色的 r,g,b\n\n\n步骤平均色值function getImgAverageColor(img) &#123;\n  const &#123; width, height &#125; = img;\n  const totalPixs = width * height;\n  let sum_r = 0,\n    sum_g = 0,\n    sum_b = 0;\n  let canvas = document.createElement(\"canvas\");\n  let context = canvas.getContext &amp;&amp; canvas.getContext(\"2d\");\n  canvas.width = width;\n  canvas.height = height;\n  context.drawImage(img, 0, 0);\n  const imgData = context.getImageData(0, 0, canvas.width, canvas.height);\n  for (let i = 0; i &lt; imgData.data.length; i += 4) &#123;\n    const r = imgData.data[i];\n    const g = imgData.data[i + 1];\n    const b = imgData.data[i + 2];\n    sum_r += r;\n    sum_g += g;\n    sum_b += b;\n  &#125;\n  const avg_r = Math.round(sum_r / totalPixs);\n  const avg_g = Math.round(sum_g / totalPixs);\n  const avg_b = Math.round(sum_b / totalPixs);\n\n  return &#123;\n    r: avg_r,\n    g: avg_g,\n    b: avg_b,\n  &#125;;\n&#125;\n\n补色function getRevertColor(r, g, b) &#123;\n  return &#123;\n    r: 255 - r,\n    g: 255 - g,\n    b: 255 - b,\n  &#125;;\n&#125;\n","categories":["技术分享"],"tags":["FrontEnd","图片","JS"]},{"title":"前端异常","url":"/2022/08/28/fe-error/","content":"前言随着前端监控体系的日益完善，前端工程师们也对异常更加地关注，大家也更重视异常捕获与消息上报，但是产生的原因以及处理办法所谈甚少，那么前端异常到底有哪些呢？\n什么是异常异常：Exception，即预料之外的事情，在程序执行的时候会打断程序正常运行。\n有哪些ECMA-262 白皮书 13 版中描述了 8 种异常：\n\nSyntaxError：语法异常\nReferenceError：引用异常\nRangeError：范围异常\nError：异常基类\nInternalError：内部异常\nTypeError: 类型异常\nEvalError: Eval 方法异常\nURIError: URI 相关方法产生的异常\n\nSyntaxError在引擎执行代码之前，编译器需要对 js 进行编译，编辑阶段包括：词法分析，语法分析。编译阶段发生的异常都是 SyntaxError，但 SyntaxError 不完全都发生于编译阶段；\n常见的 SyntaxError：\n\nSyntaxError: Invalid or unexpected token\nSyntaxError:Unexpected token u in JSON at position 0\nSyntaxError:Unexpected token ‘&lt;’\nSyntaxError:Unexpected identifier\n\nReferenceError引用异常，比较常见，类似于 Java 语言中最著名的空指针异常 (Null Pointer Exception，NPE).\n常见的有：\n\nReferenceError:$ is not defined\nReferenceError:Can&#39;t find variable: $\n\nTypeErrorTypeError 在对值进行不合理操作时会发生，比如试图对一个非函数类型的值进行函数调用，或者引用 null 或 undefined 类型的值中的属性，那么引擎会抛出这种类型的异常。\n常见的有：\n\nTypeError:Cannot read property &#39;length&#39; of undefined\n\nRangeError范围错误，比如:\n\nnew Array(-20) 会导致 RangeError: Invalid array length\n递归等消耗内存的程序会导致 RangeError: Maximum call stack size exceeded\n\nError 与自定义异常Error 是所有错误的基类，其他错误类型继承该类型。所有错误类型都共享相同的属性。\n\nError.prototype.message 错误消息。对于用户创建的 Error 对象，这是构造函数的第一个参数提供的字符串\nError.prototype.name 错误名称。这是由构造函数决定的\nError.prototype.stack 错误堆栈\n\nError: Script Error它是 Error 类型中最常见的一种；由于没有具体异常堆栈和代码行列号，成为可最神秘的异常之一。由于浏览器基于安全考虑效避免敏感信息无意中被第三方 (不受控制的) 脚本捕获到，浏览器只允许同域下的脚本捕获具体的错误信息。但大部分的 JS 文件都存放在 CDN 上面，跟页面的域名不一致。做异常监控只能捕获 Error: Script Error. 无法捕获堆栈和准确的信息。\n其他异常InternalError这种异常极为少见，在 JS 引擎内部发生，示例场景通常为某些成分过大，例如：\n\ntoo many switch cases（过多 case 子句）\ntoo many parentheses in regular expression（正则表达式中括号过多）\narray initializer too large（数组初始化器过大）\n\nEvalError在 eval() 方法执行过程中抛出 EvalError 异常\nURIError用来表示以一种错误的方式使用全局 URI 处理函数而产生的错误.decodeURI, decodeURIComponent, encodeURI, encodeURIComponent 这四个方法会产生这种异常；比如执行 decodeURI(&#39;%%&#39;) 的异常：Uncaught URIError: URI malformed.\n异常处理finallyfinally 在 try-catch 语句中是可选的，finally 子句一经使用，其代码无论如何都会执行。\nthrowthrow new Error(&#39;Boom&#39;);什么时候应该手动抛出异常呢？一个指导原则就是可预测程序在某种情况下不能正确进行下去，需要告诉调用者异常的详细信息，而不仅仅是异常内容本身。\nassert断言，如果表达式不符合预期，就抛出一个错误。assert 方法接受两个参数，当第一个参数对应的布尔值为 true 时，不会有任何提示，返回 undefined。当第一个参数对应的布尔值为 false 时，会抛出一个错误，该错误的提示信息就是第二个参数设定的字符串。\n异步中的异常非同步的代码，在事件循环中执行的，就无法通过 try catch 到。主要注意的是，Promise 的 catch 方法用于处理 rejected 状态，而非处理异常。Rejected 状态未处理的话会触发 Uncaught Rejection. 后者可以通过如下方式进行统一的监听。\nwindow.onunhandledrejection = (event) => &#123;\n  console.warn(`REJECTION: $&#123;event.reason&#125;`);\n&#125;;\n\ntips: await 这种 Promise 的同步写法，通常会被开发者忽略 rejected 的处理，可以用 try catch 来捕获。\n异常监控服务端通常会通过服务器的日志进行异常监控，比如观察单台服务器的日志输出，或 kibana 可视化查询。前端异常监控与之最大的不同，就是需要把客户端发生的异常数据通过网络再收集起来。\n参考：\n\necma-262\n前端早读课\n\n","categories":["技术分享"],"tags":["Web","FrontEnd"]},{"title":"写一个自己适用的 Vue 脚手架工具","url":"/2022/08/08/fvue/","content":"前言文中的脚手架工具已经发布到 npm，可以直接安装使用npm: vuefastGithub: fvue\n\n经常写 vue 项目的小伙伴应该都有这种经历：\n\nvue create hello-world\n\n选择各种 preset\n\n cd hello-world\n\nnpm install\n\nnpm run serve\n\n安装各种周边\n\nnpm i vuex\n\nnpm i vue-router\n\nnpm i ...\n\n...\n\n\n每新开一个项目就得按照这些步骤跑一遍，还要经常因为版本的问题，导致一些奇奇怪怪的 bugs 出现。\nso，能不能把基本都会使用的周边给弄成一个模板，然后每次新开项目的时候直接采用类似 copy 的形式来开发呢？\n正文认识 vue-cli找到 vue-cli 核心的代码：vue-cli/packages/@vue/cli/bin/vue.js\n可以发现，其实就是根据命令行交互得到的参数，然后生成对应的项目。\n以 create 命令为例：\nprogram\n  .command(\"create &lt;app-name>\")\n  .description(\"create a new project powered by vue-cli-service\")\n  .option(\n    \"-p, --preset &lt;presetName>\",\n    \"Skip prompts and use saved or remote preset\"\n  )\n  .option(\"-d, --default\", \"Skip prompts and use default preset\")\n  .option(\n    \"-i, --inlinePreset &lt;json>\",\n    \"Skip prompts and use inline JSON string as preset\"\n  )\n  .option(\n    \"-m, --packageManager &lt;command>\",\n    \"Use specified npm client when installing dependencies\"\n  )\n  .option(\n    \"-r, --registry &lt;url>\",\n    \"Use specified npm registry when installing dependencies (only for npm)\"\n  )\n  .option(\n    \"-g, --git [message]\",\n    \"Force git initialization with initial commit message\"\n  )\n  .option(\"-n, --no-git\", \"Skip git initialization\")\n  .option(\"-f, --force\", \"Overwrite target directory if it exists\")\n  .option(\"--merge\", \"Merge target directory if it exists\")\n  .option(\"-c, --clone\", \"Use git clone when fetching remote preset\")\n  .option(\"-x, --proxy &lt;proxyUrl>\", \"Use specified proxy when creating project\")\n  .option(\"-b, --bare\", \"Scaffold project without beginner instructions\")\n  .option(\"--skipGetStarted\", 'Skip displaying \"Get started\" instructions')\n  .action((name, options) => &#123;\n    if (minimist(process.argv.slice(3))._.length > 1) &#123;\n      console.log(\n        chalk.yellow(\n          \"\\n Info: You provided more than one argument. The first one will be used as the app's name, the rest are ignored.\"\n        )\n      );\n    &#125;\n    // --git makes commander to default git to true\n    if (process.argv.includes(\"-g\") || process.argv.includes(\"--git\")) &#123;\n      options.forceGit = true;\n    &#125;\n    require(\"../lib/create\")(name, options);\n  &#125;);\n\n其实就是输入完 project name 之后 执行 require(&#39;../lib/create&#39;)(name, options) 里面的方法：\nvue-cli/packages/@vue/cli/lib/Creator.js \n思路参考 vue-cli 的实现方式，我们可以实现一个适用于自己的 cli，提前编写好项目模板，只需要输入简单的交互指令，就可以生成属于我们自己的项目内容。\n具体实现准备好项目模板Realzzz1874/v3-tpl\nconst TPLS = &#123;\n  v3: &#123;\n    url: \"github:Realzzz1874/v3-tpl#fvue-tpl/v3\",\n    desc: \"v3-tpl\",\n    repo: \"https://github.com/Realzzz1874/v3-tpl/tree/fvue-tpl/v3\",\n  &#125;,\n&#125;;\n\n安装脚手架所需要的依赖包\"dependencies\": &#123;\n  \"chalk\": \"^5.0.1\",\n  \"commander\": \"^9.4.0\",\n  \"download-git-repo\": \"^3.0.2\",\n  \"handlebars\": \"^4.7.7\",\n  \"inquirer\": \"^9.1.0\",\n  \"log-symbols\": \"^5.1.0\",\n  \"ora\": \"^6.1.2\"\n&#125;\n\n开始干吧！#!/usr/bin/env node\n\nimport fs from \"fs\";\nimport &#123; program &#125; from \"commander\";\nimport download from \"download-git-repo\";\nimport inquirer from \"inquirer\";\nimport handlebars from \"handlebars\";\nimport ora from \"ora\";\nimport chalk from \"chalk\";\nimport logSymbols from \"log-symbols\";\n\nconst log = chalk.hex(\"##1DBD21\");\nconsole.log(log(\"fvue: A fast vue project cli!\"));\n\nconst TPLS = &#123;\n  v3: &#123;\n    url: \"github:Realzzz1874/v3-tpl#fvue-tpl/v3\",\n    desc: \"v3-tpl\",\n    repo: \"https://github.com/Realzzz1874/v3-tpl/tree/fvue-tpl/v3\",\n  &#125;,\n&#125;;\n\nprogram.version(\"1.0.0\");\nprogram\n  .command(\"init &lt;tpl> &lt;proj>\")\n  .description(\"init tpl\")\n  .action((tpl_name, proj_name) => &#123;\n    const &#123; url, repo &#125; = TPLS[tpl_name];\n    console.log(`github repo: $&#123;repo&#125;`);\n    const tpl_loading = ora(\"tpl downloading...\");\n    tpl_loading.start();\n    download(\n      url,\n      proj_name,\n      &#123;\n        clone: true,\n      &#125;,\n      (err) => &#123;\n        if (err) &#123;\n          tpl_loading.fail();\n          console.log(logSymbols.error, chalk.red(\"tpl download fail.\"));\n        &#125; else &#123;\n          tpl_loading.succeed(\"tpl download success.\");\n          const log = chalk.hex(\"#FFA500\");\n          console.log(logSymbols.success, log(\"tpl init success.\"));\n\n          inquirer\n            .prompt([\n              &#123;\n                type: \"input\",\n                name: \"name\",\n                message: \"please input proj name:\",\n              &#125;,\n              &#123;\n                type: \"input\",\n                name: \"description\",\n                message: \"please input proj description:\",\n              &#125;,\n              &#123;\n                type: \"input\",\n                name: \"author\",\n                message: \"please input proj author:\",\n              &#125;,\n            ])\n            .then(async (answers) => &#123;\n              const package_path = `$&#123;proj_name&#125;/package.json`;\n              const package_content = fs.readFileSync(package_path, \"utf-8\");\n              const package_result = await handlebars.compile(package_content)(\n                answers\n              );\n              fs.writeFileSync(package_path, package_result);\n              const log = chalk.hex(\"#FFA500\");\n              console.log(logSymbols.success, log(\"proj init success.\"));\n            &#125;);\n        &#125;\n      &#125;\n    );\n  &#125;);\n\nprogram\n  .command(\"list\")\n  .description(\"tpl list\")\n  .action(() => &#123;\n    for (let key in TPLS) &#123;\n      console.log(`   - $&#123;key&#125; ($&#123;TPLS[key].desc&#125;)`);\n    &#125;\n  &#125;);\nprogram.parse(process.argv);\n\n使用方法listfvue list\nfvue: A fast vue project cli!\n   - v3 (v3-tpl)\n\ninitfvue init &lt;tpl&gt; &lt;proj&gt;\n\njust like:\nfvue init v3 myVueProject\nfvue: A fast vue project cli!\ngithub repo: https:&#x2F;&#x2F;github.com&#x2F;Realzzz1874&#x2F;v3-tpl&#x2F;tree&#x2F;fvue-tpl&#x2F;v3\n✔ tpl download success.\n✔ tpl init success.\n? please input proj name: myVueProject\n? please input proj description: my fast vue project\n? please input proj author: realzzz\n✔ proj init success.\n\n结语文中的脚手架工具已经发布到 npm，可以直接安装使用\n\nnpm: vuefast\nGithub: fvue\n\nnpm i vuefast -g\n# OR\nyarn add vuefast -g\n\n安装之后，可以直接使用 fvue 命令：\n# list\nfvue list\n\n#init\nfvue init &lt;tpl&gt; &lt;proj&gt;\n","categories":["技术分享"],"tags":["Web","FrontEnd","Vue"]},{"title":"一键把 Excel 中的图片链接替换成真实图片","url":"/2022/07/25/url2pic-excel/","content":"前言日常使用 Excel 中，经常会出现其中一列是图片链接，查看的时候需要点开链接到浏览器里才能查看到具体的图片内容，反复切换十分不便，因此就想着在 Excel 中把图片链接转成真实的图片，这样查看就方便多了…\n奈何对 Excel 中的宏函数了解甚少，所以就写个 node 脚本来处理吧 :)\n说干就干思路遍历每一个单元格，如果是图片链接就下载图片然后在 Excel 中替换对应的链接。（听起来好像很简单…\nexceljs &amp; request安装 exceljs 和 request\nyarn add exceljs --save\nyarn add request --save\n\n处理 Excelconst fdirs = await fs.readdirSync(path.join(process.cwd(), \"./\"));\nconst f = fdirs.find((f) => !f.startsWith(\".\") &amp;&amp; f.endsWith(\".xlsx\"));\nawait console.info(`\\n找到 excel 文件：$&#123;f&#125;\\n`);\nconst xlsx_file = path.join(process.cwd(), `./$&#123;f&#125;`);\nconst success_file = path.join(process.cwd(), `./result_$&#123;f&#125;`);\n\nlet img_arr = [];\nconst workbook = new ExcelJS.Workbook();\nawait workbook.xlsx.readFile(xlsx_file);\nawait workbook.eachSheet((sheet) => &#123;\n  sheet.eachRow((row, row_num) => &#123;\n    row.eachCell((cell, col_num) => &#123;\n      if (cell.value.toString().startsWith(\"http\")) &#123;\n        const img_url = cell.value.toString();\n        cell.value = null;\n        // style.alignment maybe undefined\n        try &#123;\n          cell.style.alignment.horizontal = \"center\";\n          cell.style.alignment.vertical = \"justify\";\n        &#125; catch &#123;&#125;\n        const obj = &#123;\n          sheet: sheet,\n          img_url,\n          position: &#123;\n            col: col_num,\n            row: row_num,\n          &#125;,\n        &#125;;\n        img_arr.push(obj);\n      &#125;\n    &#125;);\n  &#125;);\n&#125;);\n\n处理图片const getBuffer = (img_url) => &#123;\n  return new Promise((resolve, reject) => &#123;\n    request(\n      &#123;\n        url: img_url,\n        encoding: null,\n      &#125;,\n      (error, resp, body) => &#123;\n        if (body) &#123;\n          resolve(body);\n        &#125; else &#123;\n          resolve();\n        &#125;\n      &#125;\n    );\n  &#125;);\n&#125;;\n\nconst saveImg = async (workbook, img_obj_arr) => &#123;\n  const len = img_obj_arr.length;\n  for (let i = 0; i &lt; img_obj_arr.length; i++) &#123;\n    const &#123; sheet, img_url, position &#125; = img_obj_arr[i];\n    const buff = await getBuffer(img_url);\n    if (buff) &#123;\n      log(`正在处理第 $&#123;i + 1&#125; / $&#123;len&#125; 个图片 \\n\\n`);\n      const img_base64 = buff.toString(\"base64\");\n      const img_id = workbook.addImage(&#123;\n        base64: img_base64,\n        extension: \"jpeg\",\n      &#125;);\n      const sheet_row = sheet.getRow(position.row);\n      sheet_row.height = 100;\n\n      sheet.addImage(img_id, &#123;\n        tl: &#123; col: position.col - 0.5, row: position.row - 0.5 &#125;,\n        ext: &#123; width: 100, height: 100 &#125;,\n        hyperlinks: &#123;\n          hyperlink: img_url,\n          tooltip: `$&#123;img_url&#125;`,\n        &#125;,\n      &#125;);\n    &#125;\n  &#125;\n&#125;;\n\n完整代码url2pic.js\nend","categories":["小轮子"],"tags":["Node","Excel"]},{"title":"【耳朵会说话-03】《秦皇岛》 - 万能青年旅店","url":"/2022/07/03/music-03/","content":"\n\n站在能分割世界的桥\n还是看不清 在那些时刻\n遮蔽我们 黑暗的心 究竟是什么\n\n住在我心里孤独的\n孤独的海怪 痛苦之王\n开始厌倦 深海的光 停滞的海浪\n\n站在能看到灯火的桥\n还是看不清 在那些夜晚\n照亮我们 黑暗的心 究竟是什么\n\n于是他默默追逐着\n横渡海峡 年轻的人\n看着他们 为了彼岸\n骄傲地 骄傲地 灭 亡\n","categories":["耳朵会说话"],"tags":["音乐"]},{"title":"如何将两个 git 仓库合并","url":"/2022/06/30/merge2git/","content":"前言由于一些 xxx 的原因，现在要将两个 git 仓库合并成一个，并且两个库的历史提交记录都得保留，听起来就很 xxx。\nhow to假设两个仓库分别是 A: git@github.com:Realzzz1874/a.git、B: git@github.com:Realzzz1874/b.git, 其中 A 是主仓库\n\n克隆 A\ngit clone git@github.com:Realzzz1874/a.git\n将 B 作为远程仓库，添加到 A 中，并设置别名为 repo_b\ngit remote add repo_b git@github.com:Realzzz1874/b.git\n从 B 中拉取数据到本仓库\ngit fetch repo_b\n将 B 仓库拉取的 master 分支作为新分支 checkout 到本地，设置名称为 branch_b\ngit checkout -b branch_b repo_b/master\n切换回 A 的 master\ngit checkout master\n将 branch_b 合入 A 的 master\ngit merge branch_b\n如果 6 出现错误fatal: refusing to merge unrelated histories执行：\ngit merge branch_b --allow-unrelated-histories\n如果出现 conflicts，则解决即可\n\n\n","categories":["技术分享"],"tags":[]},{"title":"Vue3.0 响应式原理","url":"/2022/06/14/Vue3.0/","content":"前言Vue3 已经发布许久，官网推荐的版本也已经直接改成了 v3，Vue3 的响应式原理是通过什么实现的呢？\n正文Vue2在了解 V3 之前，我们先来了解一下 Vue2 的原理：Object.defineProperty.\nVue2 使用的是 Object.defineProperty 来实现响应式原理。\nObject.defineProperty(obj, prop, descriptor) 接受三个参数，而且都是必填的\nobj: 要定义属性的对象\nprop: 要定义或修改的属性的名称\ndescriptor: 要定义或修改的属性描述符\n\n当一个普通的 js 对象传入 Vue 实例作为 data 选项时，Vue 将遍历 data 的所有属性，并使用 Object.defineProperty 重写这些属性的 getter/setter 方法用来追踪依赖，在属性值被访问和修改时通知变更。每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中将访问过的属性设置为依赖，之后当属性的 setter 触发时，会通知 watcher 对关联的组件进行重新渲染。\n在 Vue2 中，Vue 的响应式系统是基于 数据拦截 + 发布订阅模式，包含了四个模块：\n\nObserver: 通过 Object.defineProperty 拦截 data 的 getter/setter 方法，从而使得每一个 property 都拥有一个 Dep，当触发 getter 的时候收集依赖（使用该 property 的 watcher），当触发 setter 的时候通知更新；\nDep: 依赖收集器，用户维护 data property 的所有 watcher；\nWatcher: 将视图依赖的 property 绑定到 Dep 中，当数据修改时触发 setter，调用 Dep 的 notify 方法，通知所有依赖该 property 的 watcher 进行 update，使 property 与 视图绑定；\nCompile: 模板指令解析器，对模板的每个元素节点的指令进行扫描解析，根据指令模板替换 property 的值，同时注入 watcher 更新数据的回调方法\n\n总结： Observer 通过重写 data 各个 property 的 getter/setter 方法，对每个 property 都维护一个 Dep，用于收集依赖该 property 的所有 watcher，当该 property 触发 setter 的时候，派发更新通知。\nVue3与 Vue2 的实现不同，Vue3 的响应式原理是用 ES6 的 Proxy 方法来实现的。Proxy 用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如：属性查找、赋值、枚举、函数调用等）。可以理解为：在目标对象之前有一层“拦截”，外界对该对象的访问都必须先通过这层拦截。因此提供了一种机制：可以对外界的访问进行过滤和改写。\n// target: 目标对象，待要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）\n// handler: 一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 proxy 的行为\nconst proxy = new Proxy(target, handler);\n常见代理函数：\n\nget: 拦截对象属性的读取\nlet obj = &#123;\n  'name': \"张三\",\n&#125;\nconst proxy = new Proxy(obj, &#123;\n  // target：代理对象；key：当前的属性名\n  get(target, key) &#123;\n    return key in target ? target[key] : key\n  &#125;\n&#125;)\nconsole.log(proxy[\"name\"]) // 张三\nconsole.log(proxy[\"age\"]) // age\nset: 拦截对象属性的设置；（必须有返回值，返回值为布尔类型）\nlet obj = &#123;\n  'name': \"张三\",\n&#125;\nconst proxy = new Proxy(obj, &#123;\n  // target：代理对象；key：当前的属性名；value：新的属性值\n  set(target, key, value) &#123;\n    target[key] = value\n    return true\n  &#125;\n&#125;)\nproxy.name = '李四'\nconsole.log(proxy[\"name\"]) // 李四\nhas: 拦截 key in proxy 的操作\nlet range = &#123;\n   start: 1,\n   end: 5\n &#125;\n const proxy = new Proxy(range, &#123;\n   // target：代理对象；key：当前的属性名\n   has(target, key) &#123;\n     return key >= proxy.start &amp;&amp; key &lt;= proxy.end\n   &#125;\n &#125;)\n console.log(2 in proxy) // true\n console.log(9 in proxy) // false\ndeleteProperty: 拦截对象属性的删除\nlet obj = &#123; name: '李四', age: '18' &#125;\nconst proxy = new Proxy(obj, &#123;\n  // target：代理对象；key：当前的属性名\n  deleteProperty(target, key) &#123;\n    console.log('当前删除 :', target[key])\n    return delete target[key]\n  &#125;\n&#125;);\ndelete proxy.name\nReflect.deleteProperty(proxy, 'age')\nownKeys: 拦截对象键值的读取…\n\n\nProxy 支持 13 种拦截操作。\n总结\n\n\n\nObject.defineProperty(obj, prop, descriptor) 中的第一个参数是需要定义的对象，当我们使用后，这个对象就会被数据劫持\nProxy 实际是一个构造函数，用来生成 Proxy 实例。而且 Proxy 定义的是拦截，只是对外界访问是的过滤和改变\n\n\n\n\n\ndefineProperty 的局限性最大原因是它只能针对单例属性做监听。Vue2 中的响应性实现正是基于 defineProperty 中的 descriptor，对 data 中的属性做了遍历 + 递归，为每个属性设置了 getter、setter。这也就是为什么 Vue 只能对 data 中预定义过的属性做出响应的原因，在 Vue 中使用下标的方式直接修改属性的值或者添加一个预先不存在的对象属性是无法做到 setter 监听的(一般使用 this.$set(…) 显式声明一下)，这是 defineProperty 的局限性\nProxy 的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作，这就完全可以代理所有属性，将会带来很大的性能提升和更优的代码。Proxy 可以理解成，在目标对象之前架设一层 “拦截” ，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写\n\n\n\n\n\n在 Vue2 中，对于一个深层属性嵌套的对象，要劫持它内部深层次的变化，就需要递归遍历这个对象，执行 Object.defineProperty 把每一层对象数据都变成响应性的，这无疑会有很大的性能消耗。而在 Vue3 中，使用 Proxy 并不能监听到对象内部深层次的属性变化，因此它的处理方式是在 getter 中去递归响应性，这样做的好处是真正访问到的内部属性才会变成响应性，简单的可以说是按需实现响应性，减少性能消耗\n\n参考链接：\n\n大转转Fe - Vue3.0 响应性原理\n\n","categories":["技术分享"],"tags":["Web","FrontEnd","Vue"]},{"title":"【耳朵会说话-02】《致我的迷茫兄弟》 - 声音碎片","url":"/2022/05/26/music-02/","content":"\n\n作词 : 马玉龙\n作曲 : 马玉龙\n制作人：声音碎片\n编曲：声音碎片\n附加制作：一丁\n主唱、木吉他：马玉龙\n电吉他：李伟\n键盘：刘光蕊\n贝斯：小飞\n鼓：Alex Morris\n专辑录音室：录顶技Studio\n录音工程师：一丁\n混音工程师：Barna\n母带后期处理录音室：Barna\n母带后期处理工程师：Barna\n你好 让我们一起忘掉今天\n让我们一起抵抗虚无\n请你把鼓声敲得响亮\n飞扬的不该止于这里\n让我们再次回到街上\n像从前那样头脑清楚\n哦是的 岁月让生命变得脆弱\n机器让人性变得可疑\n娱乐让思考变得可笑\n当你在洪流之中挣扎\n什么是你的救命稻草\n你不能带着迷惑离开\n你好 沙漠里不长虚弱的草\n大海里没有无名之辈\n你母亲让你独一无二\n你不是谁的一颗棋子\n你不要轻易变成工具\n你发誓完整你的生命\n哦不管 风会向哪个方向吹拂\n握紧你手中琴和酒杯\n听它在午夜叮当作响\n这不是孤雁离群悲鸣\n这声音来自西南之南\n他孤独 可是无限清醒\n\n","categories":["耳朵会说话"],"tags":["音乐"]},{"title":"用 setTimeout 模拟 setInterval","url":"/2022/05/15/settimeout/","content":"前言\n为什么要用 setTimeout 模拟 setInterval 呢？\n\n在 JavaScript 事件循环过程中，setInterval 是一个宏任务，它的定义是：按照指定的周期（以毫秒计）来调用函数或计算表达式。\n然而我们永久了会发现，很多时候，它并不会按照我们的期望来 work。\n问题点推入任务队列后的时间不准确\nsetInterval 用法：setInterval(fn(), N);表示：fn() 将会在 N 秒之后被推入任务队列。所以，在 setInterval 被推入任务队列时，如果它前面有很多任务或者某个任务等待的时间比较长，那么这个定时器的执行时间就会和我们预定它执行的时间并不一致。\n多个定时器连续执行某些间隔会被跳过setTimeoutsetInterval 指定的时间间隔，表示的是何时将定时器的代码添加到消息队列中，而不是何时执行代码。所以真正何时执行代码的时间是不能保证的，取决于何时被主线程的事件循环取出并执行。\n\n上图可见:\n\nsetInterval 每隔 100ms 往队列中添加一个事件；\n100ms 后，添加 T1 定时器代码至队列中，主线程中还有任务在执行，所以等待，some event 执行结束后执行 T1 定时器代码；\n又过了 100ms，T2 定时器被添加到队列中，主线程还在执行 T1 代码，所以等待；\n又过了 100ms，理论上又要往队列里推一个定时器代码，但由于此时 T2 还在队列中，所以 T3 不会被添加（T3 被跳过），结果就是此时被跳过；\n这里我们可以看到，T1 定时器执行结束后马上执行了 T2 代码，所以并没有达到定时器的效果。\n\n每个 setTimeout 产生的任务会直接 push 到任务队列中；而 setInterval 在每次把任务 push 到任务队列前，都要进行一下判断(看上次的任务是否仍在队列中，如果有则不添加，没有则添加)。\nsetTimeout 模拟 setInterval\n在前一个定时器执行完前，不会向队列插入新的定时器\n保证定时器间隔\n\n\n定义 interval 方法\nlet timer = null;\ninterval(func, wait) &#123;\n    let interv = function()&#123;\n        func.call(null);\n        timer=setTimeout(interv, wait);\n    &#125;;\n    timer= setTimeout(interv, wait);\n &#125;\n和 setInterval() 一样使用它\ninterval(function() &#123;&#125;, 20);\n终止定时器\nif (timer) &#123;\n  window.clearSetTimeout(timer);\n  timer = null;\n&#125;\n\n结束","categories":["技术分享"],"tags":["Web","JS"]},{"title":"ssh manager 写个脚本来管理我的 ssh server","url":"/2022/05/06/ssh-manager/","content":"前言每次想登录一台吃灰的服务器的时候，都要想半天 host + password（找各种备忘录），于是乎想写一个小脚本来管理它们，虽然通过编辑 /.ssh/config 文件也可以实现类似功能，但是每次添加或者查看都还是需要去 cd xxx &amp; vim xxx，作为 新脚本小子，肯定得更 优雅 一点才行。\n内容github: ssh-manager\n#!/bin/bash\ncommand=$1\npath=~/.ssh/sshm/\nadd()&#123;\n    read -r -p \"server name:\" server_name\n    read -r -p \"server host:\" server_host\n    read -r -p \"server port(22):\" server_port\n    read -r -p \"server user(root):\" server_user\n    read -r -p \"server password:\" server_password\n\n    if [[ -z \"$server_name\" || -z \"$server_host\" ]]\n    then\n    \techo \"server_name or server_host does not exist\"\n    \texit;\n    fi\n\n    server_port=$&#123;server_port:-22&#125;\n    server_user=$&#123;server_user:-\"root\"&#125;\n\n\tif [ ! -d $path ]\n\tthen\n\t\t( mkdir $path )\n\tfi\n\n\tif [ ! -f $path$server_name ]\n\tthen\n\t\t( touch $path$server_name )\n\telse\n\n\t\tread -r -p \"server_name [$server_name] already exists, overwrite [o] or enter new server_name: \" action\n\t\tif [ ! $action ]\n\t\tthen\n\t\t\texit\n\t\tfi\n\n\t\tif [ $action == \"o\" ]\n\t\tthen\n\t\t\techo \"\" > $path$server_name\n\t\telse\n\t\t\tif [ $server_name == $action ]\n\t\t\tthen\n\t\t\t\techo \"server_name already exists!\"\n\t\t\t\texit\n\t\t\telse\n\t\t\t\tserver_name=$action\n\t\t\tfi\n\t\tfi\n\n\tfi\n\n    echo \"server_name=$server_name\" >> $path$server_name\n    echo \"server_host=$server_host\" >> $path$server_name\n    echo \"server_port=$server_port\" >> $path$server_name\n    echo \"server_user=$server_user\" >> $path$server_name\n    echo \"server_password=$server_password\" >> $path$server_name\n&#125;\n\nls()&#123;\n\tfor file in $path*\n\tdo\n\t\twhile read line\n\t\tdo\n\t\t    eval \"$line\"\n\t\tdone &lt; $file\n\t    echo \"`basename $file`: $server_host\"\n\t    unset server_host\n\tdone\n&#125;\n\nlogin()&#123;\n\tif [ ! -f $path$1 ]\n\tthen\n\t\techo \"server_name [$1] does not exist\"\n\t\texit\n\tfi\n\twhile read line\n\tdo\n\t    eval \"$line\"\n\tdone &lt; $path$1\n\texpect -c'\n\tspawn ssh -p '$server_port' '$server_user'@'$server_host'\n\texpect &#123;\n\t\t\"*yes/no\" &#123; send \"yes\\r\"; exp_continue&#125;\n\t\t\"*assword:\" &#123; send \"'$server_password'\\r\" &#125;\n\t&#125;\n\tinteract\n\t'\n&#125;\n\ndelete()&#123;\n\tread -r -p \"do you want to delete [y] ?\" action\n\tif [ \"$action\"x == \"y\"x ]\n\tthen\n\t\trm -rf $path$1\n\tfi\n\texit\n&#125;\n\ncase $command in\n  (add)\n     add\n     ;;\n  (ls)\n     ls\n     ;;\n  (rm)\n     delete $2\n     ;;\n  (*)\n     login $command\n     ;;\nesac\n\n用法chmod +x ./sshm.sh\n\nglobal usecp sshm.sh /usr/local/bin/sshm\n# use just like:\nsshp ls\n\naddsshm add\n\nlistsshm ls\n\nlogin serversshm server_name\n\ndeletesshm rm server_name\n\n结束","categories":["小轮子"],"tags":["shell"]},{"title":"一份工作中最重要的 5 个要素","url":"/2022/05/05/work-think/","content":"一份工作中最重要的 5 个要素\n同事是怎么样的\n老板是怎么样的\n工作空间的舒适程度\n报酬\n每天实际上在做的事情\n\n","categories":["软件开发随想录"],"tags":[]},{"title":"工作中如何高效沟通","url":"/2022/04/08/communication/","content":"","categories":["软件开发随想录"],"tags":["项目管理"]},{"title":"【耳朵会说话-01】《硬汉》 - 腰乐队","url":"/2022/03/26/music-01/","content":"\n\n作词 : 刘涛\n作曲 : 杨绍昆\n吉他：杨绍昆 洪宇\n贝斯：胡尚洪\n鼓：艾永彬\n\n调查显示国人较去年快乐\n收入低是不安全至少是不快乐根源\n当然薪水最薄的职业往往也是\n最丢脸的案例最容易悲伤的依据\n混前程是无解的题荒愁的永动机\n报废到你幸福账面蹉跎的心底\n它在你怀念的女人背景中如疯般不可抑止\n像我们爱过那只落阳深处的布鲁斯\n\n跟这没人性的现实拼命拉锯\n越拼你越没头绪乏力的马卡告诉他弟\n“生活真够刺激，莫再逼我了，\n做个粪蛋也好，只要可以过下去”\n马卡你应该明白在大多数悲剧里面\n真正的伤心很少见马卡你得试着原谅\n如果故事的方向和你要的都不一样\n我多想你能有勇气重新开场\n\n你总不忘提醒再写上一些实况吧\n把最柔顺的曲调来刻画弯路里没路的人\n当歌声四起它应该是怎样的陈述句\n才不要你太唏嘘\n被自己打败的捣蛋鬼们已经很难\n去面对厄运吐露感情和热忱\n爱谈天的软骨头我们过白天然后等夜晚\n等夜晚只为喝得到明天\n\n当通往大结局的路啊正踏平所有的祖屋和田野\n快拿出力量去桃李芬芳\n去社会栋梁去掀起权力财富的巨浪\n去担负起自家的兴旺\n去变成大人和大人物变成一个\n只有钱才可以影响到情绪的臭傻逼\n你大概会挂得很无奈但是对于亲友团的颜面\n以及统治阶梯的审美观算是有交代\n\n\n","categories":["耳朵会说话"],"tags":["音乐"]},{"title":"从 0 到 1 构建项目，正确的打开方式到底是什么？","url":"/2022/03/23/think-from0to1/","content":"前言最近一年的时间里，我一直在一个创业团队做后端开发的工作，有时候也需要跟一下项目管理之类的统筹安排，通过处理不同的事情以及和不同角色的伙伴沟通，慢慢地我也产生了一些思考。\n受自身经验与所处环境限制，这些观点不一定对，如果有人看的话，希望你们可以辩证地去思考。\n\n正文由于阅历会逐渐增加，本文内容我也将会持续更新。\n态度认真很重要懒散的态度对团队有很大的消极影响，就算是完成了任务也没有完成责任。\n不一定都得非常厉害\n聚集一群都厉害的人这件事本身就非常困难\n水平有层次更有利于团队凝聚\n不一定都得非常厉害，但是不能拖后腿\n\n先有将后有兵先搞定核心业务的核心人物再考虑扩招，而不是跟学10年前的老话：“就差一个程序员了”。\n0 到 1 的重要程度，大于 1 到 100\n0 到 1 是一个质变，1 完成了，大家才会觉得靠谱\n1 到 100 是一个量变，大家不迷茫了以后才更有方向感、凝聚力\n\n完备性会比性能更重要一个 C 端接口的投入大量的人力去优化，响应时间从 200ms 减成 100ms，乍一听优化了很多很厉害，其实呢，不如去好好设计业务需求。\n最小颗粒度及时上线很重要从 0 到 1 的时间一定不要太长，团队里的所有人，都需要一个正反馈。\n\n确认比信任更重要即使某位成员非常靠谱，备受信任，也要得到明确的结果。\n不要过度优化以前的我认为：“写得慢也不要写得烂”，现在的我更觉得：“把控不住进度都是扯淡”。\n多给团队一些反馈，哪怕是不好的有任何不合理的地方，一定要及时提出。好的行为就奖励，不好的行为就惩罚，千万不要“秋后算账”。\n负责人得先舒服了没错，就是得到“舒服”的程度，领导的面部表情有时候能决定到团队一天的效率。\n一定满足不了所有用户需求，挑关键需求做，而不是全部都做\n0 到 1 是为那些特征用户服务的，这些人能用就行了\n在 1 到 100 的阶段再去追求覆盖率， 0 到 1 的阶段先解决问题\n\n每周都花时间去总结\n自己做了哪些决定（或者否定了哪些决定）\n大家有没有成长\n最关键的点：项目进度到底可不可控\n\n及时拍板，不要怕担责任项目中一定会有错误决策，不要害怕承担责任，大家如果都在犹豫就会很容易败北。\n在没有得到用户验证的情况下，不要凭空脑补需求凭空的需求只会拖慢从 0 到 1 的进度，而且这些需求也不一定都很正确，甚至随着时间的推进，这些需求也会“凭空消失”。\n业务大于技术虽然我是技术岗位，但是我还是坚持认为 技术一定要服务于业务，技术要用来解决需求。无论抗癌药物研究的多么先进，拉肚子的时候也不会去吃它。\n从 0 到 1 更需要的是服从，从 1 到 100 必须要发散\n说服从可能有点过于阶级化，但是在 0 到 1 的阶段中，产生决策之后就是需要大家一起去执行\n1 到 100 的时候更需要大家去提升自己，做到 100 而不是只到 50\n\n……结语受自身经验与所处环境限制，这些观点不一定对，如果有人看的话，希望你们可以辩证地去思考。","categories":["软件开发随想录"],"tags":["项目管理"]},{"title":"Mysql 中的悲观锁","url":"/2022/03/12/mysql-pcc/","content":"悲观锁是什么\n在关系数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。悲观锁是对数据的修改持悲观态度（认为数据在被修改的时候一定会存在并发问题），因此在整个数据处理过程中将数据锁定。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在应用层中实现了加锁机制，也无法保证外部系统不会修改数据）。\n\n简而言之，悲观锁主要用于保护数据的完整性。当多个事务并发执行时，某个事务对数据应用了锁，则其他事务只能等该事务执行完以后才能对该数据进行修改操作。\n举个例子在商品购买场景中，当有多个用户对某个库存有限的商品同时下单，若采用先查库存再减库存的方式来变更库存数量，当出现并发的时候很可能会出现“超卖”的现象。\n-- 1. 查询出商品库存\nselect stock from goods where id = 1;\n\n-- 2. 生成订单\n...\n\n-- 3. 库存减 1\nupdate goods set stock = stock - 1 where id = 1;\n\n\n这种减库存的方式在高并发访问的情况下很可能会出现问题：\n\n用户 A、B 都查询出库存为 1\n用户 A、B 都下单\nB 先生成订单，此时库存变更为 0\nA 生成订单之后，库存就变成了 -1\n\n使用悲观锁来处理：\n\nA 获取到库存的时候，B 用户阻塞\nA 完成减库存的事务之后，B 才可以获取到商品库存\n\n如何使用悲观锁要使用悲观锁，我们必须先关闭 Mysql 的自动提交属性。\n用法：SELECT … FOR UPDATE;\nset autocommit=0;\n\n-- 开始事务\nbegin;\n\n-- 1. 查询出商品库存\nselect stock from goods where id = 1 for update;\n\n-- 2. 生成订单\n...\n\n-- 3. 库存减 1\nupdate goods set stock = stock - 1 where id = 1;\n\n-- 提交事务\ncommit;\n\n\n当 A select stock from goods where id = 1 for update 之后，此时 B 来执行同样的事务时，B 会进入等待状态，等到 A 执行完 update 操作之后，B 的事务才会提交。\n行锁与表锁当执行 SELECT … FOR UPDATE; 的时候，Mysql 会把数据锁住，因此我们需要注意锁的级别。Mysql InnoDB 默认级别为行锁。当查询语句指定了主键时，Mysql 会执行行锁，否则执行表锁。一般：\n\n若指明主键，且结果集有数据，行锁\n若指明主键，结果集无数据，则无锁\n若无主键，且非主键字段无索引，则表锁\n若使用主键但主键不明确，则使用表锁\n\nInnoDB 的行锁是通过给索引上的索引项加锁实现的，因此：只有通过索引检索数据才会采用行锁，否则使用的是表锁。\n总结悲观锁采用的是「先获取锁再访问」的策略来保障数据的安全，但是加锁策略依赖数据库实现，会增加数据库的负担，且会增加死锁的发生几率。此外，对于不会发生变化的只读数据，加锁只会增加额外不必要的负担。在实际的实践中，对于并发很高的场景并不会使用悲观锁，因为当一个事务锁住了数据，那么其他事务都会发生阻塞，会导致大量的事务发生积压拖垮整个系统。\n","categories":["技术分享"],"tags":["SQL"]},{"title":"JWT 的一点知识","url":"/2022/03/07/jwt/","content":"JWT 是什么\nJSON Web Token (JWT) 是一个开放标准(RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为 JSON 对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。\n\nJWT 长啥样JWT 是由三段信息构成的，将这三段信息用 . 连接在一起就构成了 JWT。\n\nHeader\nPayload\nSignature\n\n类似：Header.Payload.Signature\nHeaderHeader 部分是一个 JSON 对象，描述 JWT 的元数据。承载两部分信息：\n\n声明类型，JWT 的类型统一写为 JWT\n声明加密的算法，通常直接使用 HMAC SHA256\n\n比如：\n&#123;\n  'typ': 'JWT',\n  'alg': 'HS256'\n&#125;\n然后将这部分信息进行 Base64URL 算法转换成字符串，就构成了 JWT 的第一部分。\nPayloadPayload 部分用来存放实际需要传递的数据，通常有 7 个字段：\niss (issuer)：签发人\nexp (expiration time)：过期时间\nsub (subject)：主题\naud (audience)：受众\nnbf (Not Before)：生效时间\niat (Issued At)：签发时间\njti (JWT ID)：编号\n\n除了这些字段外，我们一般会定义一些私有字段来传递业务中的数据，比如：\n&#123;\n  \"name\": \"maria\",\n  \"uid\": 100001\n&#125;\nJWT 默认是不加密的，所以不要将敏感信息存储在 JWT 中\n然后将这部分信息进行 Base64URL 算法转换成字符串，就构成了 JWT 的第二部分。\nSignatureSignature 部分是对前两部分的签名，防止数据遭到篡改。\n首先，需要指定一个密钥（secret），这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名\nHMACSHA256(\n  base64UrlEncode(header) + \".\" +\n  base64UrlEncode(payload),\n  secret)\n\n算出签名之后，将 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用 . 分隔，就得到了 JWT。\nJWT 怎么用客户端收到服务器返回的 JWT 之后，可以将它存储在 cookie 里，也可以存储在 localStorage 之中。此后，客户端每次和服务器通信都带上这个 JWT，服务器收到之后进行解密校验，根据 Signature 判断是否被篡改。流程：\nJWT 应用JWT 中间件只允许一个用户登录将用户每次登录之后产生的 token 存入 redis 中， 用用户 id 做为 key。此 id 第二次登录的时候，上一次的 token 就会被覆盖。但是，在 token 未失效的情况下，第一次的 token 还是可以解码出来，payload 中的信息和第二次的一样，从而无法实现新旧 token 的对比。所以在创建 token 的时候向其中写入一个随机字符串，客户端请求带上的 token 中的 uuid 如果与 redis 存的不一样，则该 token 应该被踢下线。听起来和 session 相比好像也没什么优雅的地方。\n优缺点\nJWT 默认不加密，不要将敏感数据写入 JWT\n服务端无状态，不保存，易于扩展\n支持跨域认证（放 cookie 里不能跨域，但是放 header 里可以跨域）\n尽量使用 https\nJWT 一旦下发之后就无法废弃或者更改权限，所以有效时间尽可能短\n\n参考文章：\n\nJSON Web Token 入门教程 by: 阮一峰\nIntroduction to JSON Web Tokens\n\n","categories":["技术分享"],"tags":["BackEnd"]},{"title":"【重学前端】之 HTML","url":"/2022/03/02/study-fe-html/","content":"前言最近面试了很多前端，从应届生小白到三年经验的老炮，大家好像都很“看不起”面试被问 HTML 问题这回事。前端虽然真的很基础，但是它真的也需要被重视。\n所以我打算系统的整理一下前端所需要的知识，本文为 HTML 相关内容，后续还会有 JavaScript、CSS、框架、工程化、Node等。\n正文什么是 HTMLHTML 指的是超文本标记语言，不是编程语言，是标记语言。使用标签来描述网页内容。\n什么是语义化通过 HTML 语义化标签来表明其内部内容的意义。\n好处有：\n\n有利于 SEO、爬虫\n代码可读性更高\n访问性更好\n\n语义标签（元素）：\n\n\n\n标签\n描述\n\n\n\n&lt;article&gt;\n定义文章\n\n\n&lt;aside&gt;\n定义页面内容以外的内容\n\n\n&lt;details&gt;\n定义用户能够查看或隐藏的额外细节\n\n\n&lt;figure&gt;\n规定自包含内容，比如图示、图表、照片、代码清单等\n\n\n&lt;figcaption&gt;\n定义 &lt;figure&gt; 元素的标题\n\n\n&lt;footer&gt;\n定义文档或节的页脚\n\n\n&lt;header&gt;\n规定文档或节的页眉\n\n\n&lt;main&gt;\n规定文档的主内容\n\n\n&lt;mark&gt;\n定义重要的或强调的文本\n\n\n&lt;nav&gt;\n定义导航链接\n\n\n&lt;section&gt;\n定义文档中的节\n\n\n&lt;summary&gt;\n定义 &lt;details&gt; 元素的可见标题\n\n\n&lt;time&gt;\n定义日期/时间\n\n\nHTML 元素HTML 属性块HTML 元素一般被分为块级元素和内联元素。块级元素显示的时候会换行，内联元素不换行。\n类 (class) 与 idclass对 HTML 元素进行分类，可以为相同的类设置同样的样式。\nidid 指定 HTML 元素的唯一 id，在 HTML 文档中必须唯一。\n&lt;head&gt;: 所有头部元素的容器。\n头部元素有：\n\n\n\n标签\n描述\n\n\n\n&lt;title&gt;\n定义文档标题\n\n\n&lt;base&gt;\n定义页面上所有链接的默认地址或默认目标\n\n\n&lt;link&gt;\n引用外部资源\n\n\n&lt;meta&gt;\n定义关于 HTML 文档的元数据\n\n\n&lt;script&gt;\n引用或者定义 js\n\n\n&lt;style&gt;\n定义文档的样式信息\n\n\nCanvasHTML5 的 canvas 元素使用 js 在网页上绘制图像。canvas 元素本身是没有绘图能力的，所有的绘制工作必须在 js 内部完成。\nHTML 媒体（视频、音频）HTML5HTML5 是最新的 HTML 标准。\n本地存储web 应用程序能够在用户浏览器中对数据进行本地的存储（localStorage &amp; sessionStorage）。\n必须在 同源（同域名、同端口、同协议）下才能读取修改，sessionStorage 还需要在同窗口。\nlocalStorage 永久有效，不清空的话一直存在；sessionStorage 关闭窗口会被清空。\n都采用标准的键值对存储，键必须唯一。\n大小都是 5M.\n","categories":["技术分享"],"tags":["FrontEnd"]},{"title":"【重学前端】之 CSS","url":"/2022/03/02/study-fe-css/","content":"前言【重学前端】系列推荐： HTML 篇\nCSS 是一种描述 HTML 文档样式的语言。CSS 是前端需要掌握的最基本的技能，决定了一个程序员的下限。\n正文盒模型CSS 盒模型本质上是一个盒子，它包括：边距、边框、内容。\nCSS 盒模型包括：IE 盒模型（怪异盒模型） 和 W3C 盒模型（标准盒模型）\n标准盒模型宽度 = width + margin(left &amp; right) + padding(left &amp; right) + border(left &amp; right)\n怪异盒模型宽度 = width + margin(left &amp; right)width 已经包含了 padding 和 border 的值\n选择器\nid 选择器 (#myid)\n类选择器 (.myclass)\n属性选择器 (a[href] {color:red;})\n伪类选择器 (a:hover, li:nth-child)\n标签选择器 (div, h1,p)\n相邻选择器 (h1 + p)\n子选择器 (ul &gt; li)\n后代选择器 (li a)\n通配符选择器 (*)\n\n优先级：\n\n!important\n内联样式\nid 选择器\n类选择器 / 属性选择器 / 伪类选择器\n元素选择器 / 伪元素选择器\n关系选择器 / 通配符选择器\n\n!important &gt; 行内样式 &gt; id 选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性\nBFCBFC: Block Formatting Context, 块级格式化上下文。BFC 是一个独立的渲染区域，规定了内部的 box 如何布局，并且这个区域的子元素不会影响到外面的元素，计算 BFC 高度的时候，浮动元素也参与计算。\nBFC 的布局规则\n\n内部的 box 会在垂直方向一个接一个排列\nbox 垂直方向的距离由 margin 决定，属于同一个 BFC 的两个相邻 box 的 margin 会发生重叠\nBFC 的区域不会与 float box 发生重叠\nBFC 是一个独立容器，里面元素不会影响到外面元素\n计算 BFC 的高度的时候，浮动元素也参与计算高度\n元素的类型和 display 属性决定了这个 box 的类型，不同类型的 box 会参与不同的 formatting context\n\n如何创建 BFC\n\n根元素，即 HTML 元素\nfloat 的值不为 none\nposition 为 absolute 或者 fixed\ndisplay 的值为 inline-block\noverflow 的值不为 visible\n\nBFC 使用场景\n\n去除边距重叠\n清除浮动\n\nflexflex 是 flexible box 的缩写，意为“弹性布局”。通过指定容器的 display 属性为 flex 即可。\n容器属性：\n\nflex-direction: row | row-reverse | column | column-reverse;\nflex-wrap: nowrap | wrap | wrap-reverse;\njustify-content: flex-start | flex-end | center | space-between | space-around;\nalign-items: flex-start | flex-end | center | baseline | stretch;\nalign-content: flex-start | flex-end | center | space-between | space-around | stretch;\n\n元素属性：\n\norder 属性：定义项目的排列顺序，顺序越小，排列越靠前，默认为 0\nflex-grow 属性：定义项目的放大比例，即使存在空间，也不会放大\nflex-shrink 属性：定义了项目的缩小比例，当空间不足的情况下会等比例的缩小，如果定义个 item 的 flow-shrink 为 0，则为不缩小\nflex-basis 属性：定义了在分配多余的空间，项目占据的主轴空间\nflex: 是 flex-grow 和 flex-shrink、flex-basis 的简写，默认值为 0 1 auto\nalign-self: 允许单个项目与其他项目不一样的对齐方式，可以覆盖align-items: 默认属性为 auto，表示继承父元素的 align-items\n\n媒体查询.example &#123;\n  padding: 20px;\n  color: white;\n&#125;\n/* Extra small devices (phones, 600px and down) */\n@media only screen and (max-width: 600px) &#123;\n  .example &#123;\n    background: red;\n  &#125;\n&#125;\n\n/* Small devices (portrait tablets and large phones, 600px and up) */\n@media only screen and (min-width: 600px) &#123;\n  .example &#123;\n    background: green;\n  &#125;\n&#125;\n\n/* Medium devices (landscape tablets, 768px and up) */\n@media only screen and (min-width: 768px) &#123;\n  .example &#123;\n    background: blue;\n  &#125;\n&#125;\n\n/* Large devices (laptops/desktops, 992px and up) */\n@media only screen and (min-width: 992px) &#123;\n  .example &#123;\n    background: orange;\n  &#125;\n&#125;\n\n/* Extra large devices (large laptops and desktops, 1200px and up) */\n@media only screen and (min-width: 1200px) &#123;\n  .example &#123;\n    background: pink;\n  &#125;\n&#125;\n\n移动端适配预处理 less | sass动画","categories":["技术分享"],"tags":["FrontEnd","CSS"]},{"title":"My utils","url":"/2022/02/28/my-utils/","content":"前言在日常开发中经常会有很多命令或者工具，虽然它们只是偶尔会被使用到，但是每次用起来都得去 google，所以此篇文章用来记录这些 utils.\n都有些啥查看本地已经安装的所有的 npm 包npm list -g --depth 0 \n\n# 更新\nnpm update -g xxx\n\n# 删除\nnpm uninstall -g xxx\n\n查看指定时间范围内 npm 包的下载总量https://npm-stat.com/charts.html?package=xxx-xxx&amp;from=&amp;to=\n\nMac 下显示隐藏文件Command+Shift+. 可以显示隐藏文件、文件夹，再按一次，恢复隐藏\n\ngit 从指定分支 clone 代码git clone -b branch_name git@github.com:xxx/xxx.git\n","categories":["技术分享"],"tags":["utils"]},{"title":"微信小程序全局接管页面分享","url":"/2022/02/22/wxapp-share/","content":"前言分享是小程序裂变的一个非常重要的渠道，但是微信小程序每个页面都要写 onShareAppMessage 来配置分享内容（标题、图片、参数等），页面多的时候写起来重复性太高，所以想出能不能直接全局配置分享，统一接管。\nonShareAppMessage微信小程序开发文档·onShareAppMessage\n\n由于各个小程序开发框架写起来都不太一样，所以就改成了原生的代码\nonShareAppMessage: function () &#123;\n  return &#123;\n    title: '转发标题',\n    path: '转发路径',\n    imageUrl: '转发卡片图片'\n  &#125;\n&#125;,\n\n\n查阅文档发现，onShareAppMessage 是一个事件处理函数，用户通过点击小程序的右上角...触发，或者通过页面上的 &lt;button open-type=&#39;share&#39;&gt; 来触发，所以只需要在小程序启动的时候重写一下 onShareAppMessage 就可以了。\nonLaunch: function ()&#123;\n    wx.onAppRoute(() => &#123;\n        console.log(getCurrentPages());\n\n        const pages = getCurrentPages();\n        const current_page = pages[pages.length-1];\n        current_page.onShareAppMessage = () => &#123;\n          return &#123;\n            title: '',\n            path: current_page.route,\n            imageUrl: '转发卡片图片'\n          &#125;\n        &#125;\n    &#125;);\n&#125;\n\n","categories":["技术分享"],"tags":["微信小程序","Taro"]},{"title":"ssh2 + mysql ，nodejs 写接口如何更“安全”的操作数据库","url":"/2022/02/21/ssh2-mysql/","content":"前言为了网络安全起见，数据库和后端服务一般不会直接部署在同一台机器上，且一般也不允许直接用账户+密码的方式直接连接，通常采取的方案是通过 ssh 的方式进行连接。\n项目已经封装成 npm 包：ssh2-connect-mysql\ngithub 地址：ssh2-connect-mysql\n步骤\n建立 ssh 连接\n与 mysql 建立连接\n得到 mysql 操作句柄\n\n实现方式const client = require(\"ssh2\").Client;\nconst mysql = require('mysql2');\n\nconst _client = new client();\n\n// see config: https://github.com/mscdex/ssh2\nconst ssh_conf = &#123;\n  host: 'xxx.xxx.xx.1',\n  port: 22,\n  username: 'maria',\n  privateKey: fs.readFileSync('/path/to/my/key')\n&#125;;\n\n// see config: https://github.com/sidorares/node-mysql2\nconst db_conf = &#123;\n  host: 'xxx.xxx.xx.2',\n  user: 'realzzzdb',\n  password: 'qwer123..',\n  database: 'mydb'\n&#125;;\n\n// 建立 ssh 连接\n_client.on(\"ready\", function () &#123;\n    _client.forwardOut(\n      \"127.0.0.1\",\n      12345,\n      db_config.host,\n      db_config.port,\n      function (err, stream) &#123;\n        if (err) &#123;\n          _client.end();\n          return renject(\"Connection failed.\");\n        &#125;\n\n        // 得到 stream\n        db_config.host = 'localhost';\n        db_config.stream = stream;\n\n        // 得到 mysql 的操作句柄\n        _sql = mysql.createConnection(db_config);\n        \n      &#125;\n    ).connect(ssh_config); // ssh 连接的参数\n  &#125;);\n\n更好的使用，封装成 npm 包npm package: ssh2-connect-mysql\ngithub page: ssh2-connect-mysql\n","categories":["技术分享"],"tags":["Node","BackEnd"]},{"title":"前端监控埋点方案（GIF）","url":"/2022/02/17/gif-page-tracking/","content":"为什么需要埋点互联网 2.0 时代的产品比较喜欢讲究千人千面，运营与产品团队非常注重观察用户使用产品的行为轨迹，从而能够精准推荐到“猜你喜欢”。研发团队也会非常关注产品的性能和异常，确保产品的高性能以及高安全性。\n埋点 &amp; 上报埋点（监控）内容\n用户数据\n\nPV / UV\n点击位置 / 浏览位置 / 浏览时间\n入口\n触发的行为\n……\n\n\n页面性能\n\n不同用户不同机型不同系统加载时间\n接口请求时间 / 页面渲染时间\n……\n\n\n系统异常\n\n系统报错\n……\n\n\n\n上报常见上报方式：\n\n请求接口\n\n请求普通文件\n\n请求图片\n\n\n弊端：\n\n请求接口：场景复杂，容易出现跨域\n\n请求普通文件（js/css/ttf 等）：浏览器创建 DOM 树之后才会请求资源节点，大量请求 js/css 等资源还会阻塞页面渲染\n\n\n选择图片打点的原因：\n图片打点不需要操作 DOM，得利于 img 的 src 属性，只需要在 js 中 new 一个 image 对象就可以发起请求，而且也没有页面阻塞的问题，且页面关闭的时候，采用 img 发出的请求也不会被取消。\n\nlet img = new Image();\nimg.src = 'https://static.example.com/track.gif?data=xxx';\n\n图片为什么选择 GIF同样是 1x1 像素的透明图片，GIF 的体积最小。\n\n最小的 BMP 文件需要 74 个字节\n最小的 PNG 需要 67 字节\n最小的 GIF 需要 43 字节\n\n前端埋点选择 GIF 的主要原因\n不跨域\n不阻塞页面加载\n体积小\n闭页面的时候图片的请求还能发出去\n\n","categories":["技术分享"],"tags":["FrontEnd"]},{"title":"提升一点点也是值得的，使用 box-shadow 的时候应该避免重绘","url":"/2022/02/09/box-shadow/","content":"前言在渲染长列表的时候，经常有这样的需求：悬浮在列表的 item 上，会“高亮”显示当前的 hover 内容，虽然数据量少的时候没有明显的卡顿感受，但是如果数据量过大或者操作过于频繁，就会感受到页面有一点点的“呆滞”。\n原因直接动态添加 box-shadow 属性的时候，每一次操作都会进行重绘 (repaint)，会损耗页面渲染的性能。\n优化方案通过修改伪类元素的透明度来实现 box-shadow\n原理：通过改变透明度，这样其实是从一个非默认值来更新它的值，不需要进行重绘。\n写法对比old&lt;div class=\"old\">&lt;/div>\n\n.old &#123;\n  padding: 20px;\n  background-color: #ffffff;\n  transition: 0.2s;\n&#125;\n.old:hover &#123;\n  box-shadow: 0 0 10px 0 rgba(0, 0, 0, 0.3);\n&#125;\n\nnew&lt;div class=\"new\">&lt;/div>\n\n\n设置一个空的伪元素，设置它的透明度为0\n\n.new::after &#123;\n    content: \"\";\n    position: absolute;  \n    top: 0;\n    right: 0;\n    bottom: 0;  \n    left: 0;\n    z-index: -1;\n    box-shadow: 0 0 10px 0 rgba(0, 0, 0, 0.3);\n    opacity: 0;\n    will-change: opacity;\n    transition: 0.2s;\n&#125;\n\n\n通过鼠标悬停，恢复它的透明度\n\n.new:hover::after &#123;\n  opacity: 1;\n&#125;\n\n效果\n","categories":["技术分享"],"tags":["Web","CSS"]},{"title":"如何发布一个npm包","url":"/2022/01/28/npm-publish/","content":"创建 npm 账号\n在 npm 官网 注册创建 npm 账号\n设置好 2FA 认证 （参考：阮一峰：2FA 认证教程）\n\n创建 npm 包以 jojoi 为例:\n\n新建文件夹 jojoi\n进入文件夹，执行 npm init, 配置好 options 之后，会生成一个 package.json\n编码 index.js\n推送 jojoi 到 github\n\n发布\n检查 npm 源\n// 查看 npm 源地址\nnpm config get registry\n\n// 设置 npm 默认源\nnpm config set registry https://registry.npmjs.org/\n\n// 设置 npm 源为淘宝镜像\nnpm config set registry https://registry.npm.taobao.org/\n在项目中登录 npm\nnpm login\n// 控制台会提示输入相关信息\nLog in on https://registry.npmjs.org/\nUsername:  // 用户名\nPassword: // 密码\nEmail: (this IS public) // 邮箱\nEnter one-time password: // 2FA 密钥\nLogged in as xxx on https://registry.npmjs.org/.\n\n发布\nnpm publish\n// 如果发布公开包的话：\nnpm publish --access public\n\n更新 npm 包// 自动更改版本号，并且commit\n// 控制台会返回下一个小版本号 如v1.0.1\nnpm version patch\n\n// 重新发布\nnpm publish\n\n// patch：补丁号，修复bug，小变动，如 v1.0.0->v1.0.1\nnpm version patch\n\n// minor：次版本号，增加新功能，如 v1.0.0->v1.1.0\nnpm version minor\n\n// major：主版本号，不兼容的修改，如 v1.0.0->v2.0.0\nnpm version major\n\n","categories":["小轮子"],"tags":["工具","npm"]},{"title":"My Custom CSS Reset","url":"/2022/01/27/css-reset/","content":"前言每当我开始一个新项目时，首要的任务就是处理 CSS 语言中的那些边边角角的问题。为了解决这些问题，通常会使用自定义的一组基础样式。\nMy CSS Reset持续更新…\n/*\n  Custom CSS Reset\n*/\n*, *::before, *::after &#123;\n  box-sizing: border-box;\n&#125;\n* &#123;\n  margin: 0;\n&#125;\nhtml, body &#123;\n  height: 100%;\n&#125;\nbody &#123;\n  line-height: 1.5;\n  -webkit-font-smoothing: antialiased;\n&#125;\nimg, picture, video, canvas, svg &#123;\n  display: block;\n  max-width: 100%;\n&#125;\ninput, button, textarea, select &#123;\n  font: inherit;\n&#125;\np, h1, h2, h3, h4, h5, h6 &#123;\n  overflow-wrap: break-word;\n&#125;\n#root, #__next &#123;\n  isolation: isolate;\n&#125;\n\n\n@mixin flex($f_d: column, $j_c: normal, $a_i: normal) &#123;\n  display: flex;\n  flex-direction: $f_d;\n  justify-content: $j_c;\n  align-items: $a_i;\n&#125;\n\n@mixin w_h($w: auto, $h: auto) &#123;\n  @if $w != auto &#123;\n    width: #&#123;$w&#125;px;\n  &#125; @else &#123;\n    width: auto;\n  &#125;\n  @if $h != auto &#123;\n    height: #&#123;$h&#125;px;\n  &#125; @else &#123;\n    height: auto;\n  &#125;\n&#125;\n\n@mixin font($s: 24, $c: #444, $l: 24, $f: 400) &#123;\n  font-size: #&#123;$s&#125;px;\n  color: #&#123;$c&#125;;\n  line-height: #&#123;$l&#125;px;\n  font-weight: #&#123;$f&#125;;\n&#125;","categories":["小轮子"],"tags":["Web","CSS"]},{"title":"Taro 中使用 Vuex & 数据持久化存储","url":"/2022/01/10/taro-vuex/","content":"前言许久没有关注小程序的生态圈发展，这两天发现在造轮子这一块，各大厂商都玩的天花乱坠。最近打算开始试试由京东开发的 Taro，记录一下上手体验以及遇到的一些小问题。\n是什么官方说明：\n\nTaro 是一个开放式跨端跨框架解决方案，支持使用 React/Vue/Nerv 等框架来开发 微信 / 京东 / 百度 / 支付宝 / 字节跳动 / QQ / 飞书 小程序 / H5 / RN 等应用。\n\n简言之，Taro 旨在：**只编写一套代码，就能够多端运行。**\n上手具体流程可参考官方文档：Taro\n数据状态管理 (Vuex)由于我选择的是 Vue 来开发，所以状态管理选择的是 Vuex.\n\n安装 vuex\nyarn add vuex\n项目集成\n\n新建 src/store/index.js\n\nimport Vue from \"vue\";\nimport Vuex from \"vuex\";\nVue.use(Vuex);\nexport default new Vuex.Store(&#123;\n  state: &#123;\n    userinfo: &#123;\n      nickname: \"zhangsan\",\n    &#125;,\n  &#125;,\n  mutations: &#123;&#125;,\n&#125;);\n\n\napp.js 中引入 store\n\n// 部分代码\nimport store from \"./store\";\n\nconst App = &#123;\n  store,\n  render(h) &#123;\n    return h(\"block\", this.$slots.default);\n  &#125;,\n&#125;;\n\nexport default App;\n\n至此发现，**和 Vue 的开发也没什么区别**\n数据持久化存储选用 vuex-persistedstate\n\n安装\nyarn add vuex-persistedstate\n项目集成\n\n改造 src/store/index.js\n\nimport Vue from \"vue\";\nimport Vuex from \"vuex\";\nimport persistedState from \"vuex-persistedstate\";\nVue.use(Vuex);\nexport default new Vuex.Store(&#123;\n  state: &#123;\n    userinfo: &#123;\n      nickname: \"zhangsan\",\n    &#125;,\n  &#125;,\n  mutations: &#123;\n    testChangeNickname: (state, payload) => &#123;\n      state.userinfo.nickname = payload.nickname;\n    &#125;,\n  &#125;,\n  plugins: [persistedState()],\n&#125;);\n\n在 state 中特别加入 userinfo: &#123; nickname: &#39;zhangsan&#39; &#125;, mutations 中加入 testChangeNickname 来测试调用。\n编译发现很尴尬，报错了。\nsetItem of undefined\n看起来是 persistedState 的 storage 默认使用的是 window 所导致的，而小程序里肯定不能直接调用 window.\n\n再改 src/store/index.js\n\n// 部分代码\nimport Taro from \"@tarojs/taro\";\nplugins: [\n  persistedState(&#123;\n    storage: &#123;\n      getItem: (key) => &#123;\n        return Taro.getStorageSync(key);\n      &#125;,\n      setItem: (key, value) => &#123;\n        Taro.setStorageSync(key, value);\n      &#125;,\n      removeItem: (key) => &#123;\n        Taro.removeStorageSync(key);\n      &#125;,\n    &#125;,\n  &#125;),\n];\n\n将 getItem、setItem、removeItem 全部改成 Taro 调用\n编译正常。\n\n业务测试\n\n获取 state\n\ncomputed: &#123;\n  nickname() &#123;\n    return this.$store.state.userinfo.nickname\n  &#125;\n&#125;,\n\n\n触发 mutations\n\nthis.$store.commit(\"testChangeNickname\", &#123; nickname: \"lisi\" &#125;);\n\n结语至此，完成 Taro 中使用 Vuex &amp; 数据持久化存储。\n持续踩坑中…\n","categories":["技术分享"],"tags":["微信小程序","Taro"]},{"title":"自己写一个掘金自动签到的脚本","url":"/2021/11/29/auto-juejin/","content":"前言1024 的时候我发现掘金的福利兑换礼品真的是白菜价，奈何如此少的矿石，我依然没有。我每天开始去签到，只是为了来年 1024 的时候去挥霍一番，可是我发现每天都念叨这件事情属实让我很不舒服，因为只有女朋友可以让我每天如此思念 T_T\n所以我决定写个自动签到的脚本来帮我干这件事情 (:\n功能点自动签到聪明的人打开浏览器控制台就可以找到签到对应的接口:\n\n查询今日是否已经签到：\n\nhttps://api.juejin.cn/growth_api/v1/get_today_status\n\n\n签到：\n\nhttps://api.juejin.cn/growth_api/v1/check_in\n\n这样一来就非常简单了，先获取一下签到状态，没签到的去签个到：\n// 查询今日是否已经签到\nconst getTodayCheckStatus = async () => &#123;\n  const cookie = '从浏览器的请求头里 copy 一个 cookie';\n  let &#123; data &#125; = await axios(&#123;\n    url: 'https://api.juejin.cn/growth_api/v1/get_today_status',\n    method: \"get\",\n    headers: &#123;\n      Cookie: cookie,\n    &#125;,\n  &#125;);\n  return &#123;\n    error: data.err_no !== 0,\n    isCheck: data.data,\n  &#125;;\n&#125;;\n\n// 签到\nconst checkIn = async () => &#123;\n  let &#123; error, isCheck &#125; = await getTodayCheckStatus();\n  if (error) &#123;\n    console.log('验证签到错误');\n    return;\n  &#125;\n  if (isCheck) &#123;\n    console.log('已经签到');\n    return;\n  &#125;\n  const cookie = '从浏览器的请求头里 copy 一个 cookie';\n  let &#123; data &#125; = await axios(&#123;\n    url: 'https://api.juejin.cn/growth_api/v1/check_in',\n    method: \"post\",\n    headers: &#123;\n      Cookie: cookie,\n    &#125;,\n  &#125;);\n  if (data.err_no) &#123;\n    console.log('签到失败');\n  &#125; else &#123;\n    console.log('签到成功');\n  &#125;\n&#125;;\n\n顺带免费抽奖聪明的人又打开了浏览器的控制台找到了抽奖对应的接口:\n\n获取抽奖配置：\n\nhttps://api.juejin.cn/growth_api/v1/lottery_config/get\n\n\n发起抽奖\n\nhttps://api.juejin.cn/growth_api/v1/lottery/draw\n\n这样一来就又非常简单了，先获取一下抽奖状态，没抽奖的去抽个奖：\nconst getTodayLotteryStatus = async () => &#123;\n  const cookie = '从浏览器的请求头里 copy 一个 cookie';\n  let &#123; data &#125; = await axios(&#123;\n    url: 'https://api.juejin.cn/growth_api/v1/lottery_config/get',\n    method: \"get\",\n    headers: &#123;\n      Cookie: cookie,\n    &#125;,\n  &#125;);\n  if (data.err_no) &#123;\n    return &#123;\n      error: true,\n      isLotteryed: false,\n    &#125;;\n  &#125; else &#123;\n    return &#123;\n      error: false,\n      isLotteryed: data.data.free_count === 0,\n    &#125;;\n  &#125;\n&#125;;\n\n// 抽奖\nconst draw = async () => &#123;\n  let &#123; error, isLotteryed &#125; = await getTodayLotteryStatus();\n  if (error || isLotteryed) &#123;\n    console.log('抽过啦');\n    return;\n  &#125; \n  const cookie = '从浏览器的请求头里 copy 一个 cookie';\n  let &#123; data &#125; = await axios(&#123;\n    url: 'https://api.juejin.cn/growth_api/v1/lottery/draw',\n    method: \"post\",\n    headers: &#123;\n      Cookie: cookie,\n    &#125;,\n  &#125;);\n  if (data.err_no) &#123;\n    console.log('抽奖失败啦');\n    return;\n  &#125;\n  console.log('抽奖结果:\\n' + data);\n&#125;;\n\n失败了再顺带给我发个邮件邮件服务可以参考：nodemailer\nconst sendEmail = async (subject, html) => &#123;\n  // xxx\n&#125;;\n\n将上面函数里失败的 console.log() 替换成邮件提醒 await sendEmail()\n丢到服务器上每天定时执行let job = new Cron(\n  \"10 10 10 * * *\",\n  async () => &#123;\n    await checkIn();\n    await draw();\n  &#125;,\n  null,\n  true,\n  'Asia/Shanghai'\n);\n\njob.start();\n\n注意事项由于 cookie 会过期，所以失败之后可以尝试在浏览器里重新 copy 一个 cookie 到脚本里执行。\n","categories":["小轮子"],"tags":["Node","BackEnd"]},{"title":"珍品收藏links","url":"/2021/11/18/favorite-links/","content":"珍品收藏dev开发常见：\n\ntinypng\n\nbase64图片在线转换工具\n\nUU在线工具\n\ni Hate Regex - The Regex Cheat Sheet\n\nRGB颜色值与十六进制颜色码转换工具\n\nAn image cache &amp; resize service.\n\nNavicat for MySQL 15注册激活\n\n插图-Illustrations | unDraw\n\n插图-404 Illustrations\n\nError 404 png\n\nCarbon | Create and share beautiful images of your source code\n\nAnimista - CSS Animations on Demand\n\n表情速查\n\npublic APIs\n\n统计 npm 包下载数量\n\n\ndaily生活类：\n\n违法不良信息举报中心\n\nGenerate a Random Name - Fake Name Generator\n\n免费短信接收-有信云短信\n\nTemp Mail - 临时性 - 匿名电子邮件\n\n消除图片中的背景 – remove.bg\n\nsquoosh-图片压缩\n\nthis person does not exist\n\n手写思维导图\n\n\n","categories":[],"tags":[]},{"title":"【图片压缩二】使用node批量压缩图片","url":"/2021/10/22/image-node/","content":"前言相比于一些APP或者在线网站，有时候我们的业务工程里需要集成压缩图片的功能，node环境下，imagemin 就非常适合做这件事情。\n概述imagemin是一种插件模式的压缩工具，需要根据所需压缩图片的格式来按需加载对应的插件。\nnpm install imagemin\nnpm install imagemin-jpegtran // OR imagemin-mozjpeg\nnpm install imagemin-pngquant\nnpm install imagemin-svgo\nnpm install imagemin-imagemin-webp\n\n使用方法\n压缩目录images下的图片文件，输出文件到目录下：\n\nimport imagemin from 'imagemin';\nimport imageminMozjpeg  from 'imagemin-mozjpeg';\nimport imageminPngquant from 'imagemin-pngquant';\n\n(async () => &#123;\n  const files = await imagemin(['images/*.&#123;jpg,png&#125;'], &#123;\n    destination: 'build',\n    plugins: [\n      imageminMozjpeg(&#123;\n        quality: 50,\n      &#125;),\n      imageminPngquant(&#123;\n        quality: [0.5, 0.8]\n      &#125;)\n    ]\n  &#125;);\n  console.log(files);\n&#125;)();\n\n\n修改成函数式：传入图片的base64，输出压缩后的base64\n\nimport imagemin from 'imagemin';\nimport imageminMozjpeg  from 'imagemin-mozjpeg';\nimport imageminPngquant from 'imagemin-pngquant';\n\n(async () => &#123;\n  const base64Str = '';\n  const ogBuffer = Buffer.from(base64Str, \"base64\");\n\n  const files = await imagemin.buffer(ogBuffer, &#123;\n    plugins: [\n      imageminMozjpeg(&#123;\n        quality: 50,\n      &#125;),\n      imageminPngquant(&#123;\n        quality: [0.5, 0.8]\n      &#125;)\n    ]\n  &#125;);\n\n  console.log(files.toString('base64'));\n\n&#125;)();\n","categories":["小轮子"],"tags":["Node","图片"]},{"title":"根据 IP 限制访问接口的频率","url":"/2021/10/20/ratelimit/","content":"前言业务上线之后，经常会出现一些来路不明的人在持续不断的请求业务接口，这些请求就算没有产生数据安全问题也会对业务服务器产生一些压力，那么如何拦截这些请求就成了一个不得不去面对的问题。解决方案有很多种，其中之一就是：**根据 IP 限制访问接口的频率**\n设计思路以 10 秒钟之内请求次数不超过 20 次为例\n\n把请求的 ip 和接口路由 path 拼接起来作为 key，把请求的次数作为 value，存进 Redis，并设置过期时间为 10 秒\n\n第一次请求设置 value 为 1，以后每次请求 value + 1\n\n每一次请求都重置过期时间，并且判断 value 是否大于 10\n\n如果没过期，且 value 大于 10，则是应该被限制的请求\n\n\n伪代码以 eggjs/midway 中间件为例\nconst cacheName = `$&#123;ip&#125;-$&#123;path&#125;`; // key\n\nconst ttl = await redisService.ttl(cacheName); // key是否有剩余时间\n\nif (ttl > 0) &#123;\n  const count = await redisService.read(cacheName); // key已经请求的次数\n  if (count &amp;&amp; +count &lt; 20) &#123;\n    // 如果还没到20次，次数加1，重置过期时间，正确返回\n    await redisService.write(cacheName, count + 1, ttl);\n    await next();\n  &#125; else &#123;\n    // 次数大于阈值，拦截，返回429\n    throw Error(\"too many requests\", 429);\n  &#125;\n&#125; else &#123;\n  // ttl &lt; 0, 重新写\n  await redisService.write(cacheName, 1, 10);\n  await next();\n&#125;\n","categories":["技术分享"],"tags":["Node","BackEnd"]},{"title":"【图片压缩一】Python结合TinyPNG批量压缩图片","url":"/2021/10/19/image-tinypng-py/","content":"前言在使用TinyPng压缩图片的时候经常会遇到需要一次性压缩很多张，网站使用起来需要本地选择图片然后上传再下载压缩之后的图片，很不方便，所以想搞一个脚本在本地运行可以递归压缩文件夹及子文件夹中的所有图片。\n准备工作安装一下tinify\npip install --upgrade tinify\n\n核心科技import tinify\nimport os\nimport os.path\n\ntinify.key =\"XXXXXXXX\" # AppKey--tinypng申请的key\nfromPath =\"/Users/xxx/Desktop/temp-test/pic-test/source\" # source path\ntoPath =\"/Users/xxx/Desktop/temp-test/pic-test/dest\" # dest path\n\nfor root, dirs, files in os.walk(fromPath):\n newToPath = toPath\n if len(root) > len(fromPath):\n  innerPath= root[len(fromPath):]\n  if innerPath[0] == '/':\n   innerPath = innerPath[1:]\n  newToPath =  os.path.join(toPath,innerPath)\n\n for name in files:\n  newFromFilePath = os.path.join(root, name)\n  newToFilePath = os.path.join(newToPath, name)  \n  fileName, fileSuffix = os.path.splitext(name)\n  if fileSuffix == '.png' or fileSuffix == '.jpg':\n   source = tinify.from_file(newFromFilePath)\n   source.to_file(newToFilePath)\n  else:\n   pass\n\n for dirName in dirs:\n  os.mkdir(os.path.join(newToPath, dirName))\n\n","categories":["小轮子"],"tags":["图片","Python"]},{"title":"我不希望别人可以随意调试我的网站代码","url":"/2021/08/28/browser-debugger/","content":"起因在某次爬虫（科学获取网站资讯数据）的时候，我打开了该网站的控制台，通过Network 和Sources 两个Tab选项，我发现很容易就调试出了它的接口请求参数，当时就整个一洋洋得意。但是我转念一想，如果是我自己的网站，我不希望别人也可以这样轻而易举地调试我的页面，我应该怎么防止呢？\n预防手段在开发过程中，我们通常会在页面上打很多断点用来调试，我突发奇想，如果有人打开页面的控制台，我让他一直处于debugger当中，这样不就让他没法进行下一步了吗？\n这个简单，几行代码的事情\n(() => &#123;\n  setInterval(() => &#123;\n    debugger;\n  &#125;, 100);\n&#125;)();\n\n这段代码的作用是：通过一直处于debugger状态来阻塞你程序的执行，没办法在Source Tab中对js进行加断点，没办法继续调试程序的执行逻辑。但是Sources Tab选项中，我们可以添加Ignore List来过滤掉我们加的debugger\n这样设置，页面中的debugger就不生效了…\n但是，只要思想不滑坡，困难总比方法多\n(() => &#123;\n  setInterval(() => &#123;\n    Function(\"debugger\")();\n  &#125;, 100);\n&#125;)();\n\nFunction生成的debugger会在每一次执行的时候都开启一个临时的js文件，而你的Ignore List只能遇到一次加一次，永远落后我的脚步&#x1F61B;\n说干就干既然这样，我不如直接写个webpack插件，给每个.js文件都加上这段话，岂不是美滋滋~\n核心代码：\nconst &#123; ConcatSource &#125; = require('webpack-sources')\n\nclass AddDbugJs &#123;\n  constructor () &#123;&#125;\n\n  apply (compiler) &#123;\n    compiler.hooks.afterCompile.tapAsync(&#123;\n      name: 'AddDbugJs',\n    &#125;, (compilation, callback) => &#123;\n      let assetNames = Object.keys(compilation.assets)\n      for (const name of assetNames) &#123;\n        if (name.endsWith('.js')) &#123;\n          let dbug = `setInterval(() => &#123;(function () &#123;return false;&#125;[\"constructor\"](\"debugger\")[\"call\"]());&#125;, 100);`\n          compilation.updateAsset(\n            name,\n            old => new ConcatSource(old, '\\n', dbug),\n          )\n        &#125;\n      &#125;\n      callback()\n    &#125;)\n  &#125;\n&#125;\n\nmodule.exports = AddDbugJs\n\n\n在项目中使用它：\nconst AddDbugJs = require('add-dbug-js')\nmodule.exports = &#123;\n  devServer: &#123;&#125;,\n  configureWebpack: &#123;\n    plugins:\n      process.env.NODE_ENV !== 'production'\n        ? []\n        : [new AddDbugJs()],\n  &#125;,\n&#125;\n\n这就成了 &#x1F973;\n","categories":["技术分享"],"tags":["Web"]},{"title":"反爬虫机制和破解方法汇总","url":"/2021/08/25/crawl-tips/","content":"说明网络不是法外之地，请大家文明上网\n\n反爬虫机制\n通过UA 识别爬虫有些爬虫的UA很好识别，比如百度，与正常浏览器的UA是不一样的，可以通过识别UA的方法直接封禁此类请求\n\n设置IP的访问频率如果同一个IP超过一定频率，可以通过弹出验证码的方式来过滤机器人（如何巧妙设置验证，也是一个很有意思的问题）\n\n通过并发识别爬虫很多爬虫的并发率是非常高的，当达到一定阈值，可以直接封禁\n\n限制单个 IP/API token的访问量\n\n识别出合法爬虫设置合法爬虫的白名单，例如百度的自动收录等，如果不是合法爬虫则可以直接封禁\n\n蜜罐资源蜜罐资源策略简单来说就是 钓鱼执法 ，通过在页面上设置一些隐式链接，普通用户无法访问，一旦有IP请求了这些资源，则可以判断这些IP是爬虫的IP\n\n\n破解反爬虫机制\n设置下载延迟\n\n禁止cookie很多网站会通过cookie识别用户身份，禁止cookie可以让服务器无法追踪爬虫轨迹\n\n使用UA池每次发送爬虫请求的时候，从UA池里随机使用一个UA\n\n使用IP池每次发送爬虫请求的时候，使用不同的代理IP\n\n分布式爬取\n\n模拟登录\n\n\n","categories":["技术分享"],"tags":["爬虫"]},{"title":"使用Steam作为第三方账号登录你的网站","url":"/2021/08/22/steam/","content":"前言  在日常网络冲浪中，很多网站要求我们注册登录的时候，我们都可以选择使用 QQ|微信|微博|Github 等作为第三方账号去登录。那么如果我的网站都是游戏相关的内容，我可不可以让用户 使用 Steam 作为第三方账号登录 呢？\n问题分析基于网页浏览器的 OpenID 验证如 OpenID 2.0（了解更多） 规范所描述，Steam 只是一个 OpenID 的提供者。在网页浏览器内，第三方网站可以使用 OpenID 来获取用户的 SteamID ，用户的 SteamID 可以用来作为第三方网站的登录凭据（登录）或者与第三方网站的既有账户绑定（注册）。\n流程描述当用户希望登录第三方网站并且将自己的账号与 Steam 账号绑定，第三方网站将用户重定向到 Steam 社区的登录授权页面，用户输入 Steam 的登录凭证后，浏览器自动重定向回第三方网站，并将一些额外的 OpenID 数据写入返回的 URL 中。这些数据通过验证之后即可解析出用户的 SteamID 。\n具体操作申请一个用来校验信息的 ApiKey到这里申请 =&gt; steamcommunity\n构造用来登录的链接参数说明：\nsteamLoginUrl: https://steamcommunity.com/openid/login\nreturnUrl: Steam社区登录之后重定向的链接，一般为登录之后的网站首页 https://xxx.com\nrealm: steam社区授权页面显示的第三方网站名称\n\n// 返回的链接\nconst url = `$&#123;steamLoginUrl&#125;?openid.ns=http://specs.openid.net/auth/2.0&amp;openid.mode=checkid_setup&amp;openid.return_to=$&#123;returnUrl&#125;&amp;openid.realm=$&#123;realm&#125;&amp;openid.identity=http://specs.openid.net/auth/2.0/identifier_select&amp;openid.claimed_id=http://specs.openid.net/auth/2.0/identifier_select`;\n\n当用户点击网页上的 Steam 登录标识的时候，浏览器将用户重定向到 url ，在用户授权之后，会回到 returnUrl 页面。\n校验Steam返回的数据当 Steam 成功授权登录返回到我们的 returnUrl 页面之后，页面链接中会带有很多额外信息：\nconst respUrl = `$&#123;returnUrl&#125;?openid.ns=http://specs.openid.net/auth/2.0&amp;openid.mode=id_res&amp;openid.op_endpoint=https://steamcommunity.com/openid/login&amp;openid.claimed_id=https://steamcommunity.com/openid/id/xxxxxxxxxxx&amp;openid.identity=https://steamcommunity.com/openid/id/xxxxxxxxxxx&amp;openid.return_to=https:/%mywebsite.com&amp;openid.response_nonce=2020-08-27T04:44:16Zs4DPZce8qc+iPCe8JgQKB0BiIDI=&amp;openid.assoc_handle=1234567890&amp;openid.signed=signed,op_endpoint,claimed_id,identity,return_to,response_nonce,assoc_handle&amp;openid.sig=W0u5DRbtHE1GG0ZKXjerUZDUGmc=`;\n\n\n具体的参数说明可参考steam官方文档\n因为返回的参数中带有用户的 SteamID 字段，为了保证信息安全，我们需要对数据进行正确性校验。定义 params = respUrl ? 后面的内容\n\n替换 params 中的 openid.mode=id_res 为 openid.mode=check_authentication\n\n构造校验链接\n const validateUrl = `https://steamcommunity.com/openid/login?$&#123;params&#125;`;\n通过 GET 请求 validateUrl 得到校验结果 得到一个 text/plain 类型的response：\n ns:http://specs.openid.net/auth/2.0\nis_valid:true\n\n is_valid:true 表明校验通过。\n\n\n通过用户的SteamID来获取用户的个人信息当校验完用户的 Steam 登录之后，我们便可以在返回的数据中获取到用户的 SteamID 。\n`openid.identity=https://steamcommunity.com/openid/id/xxxxxxxxxxx(此处则是用户的SteamID)`\n\n通过 Steam 平台开放接口，我们则可以获取到用户的 Steam 个人信息。\nGET 请求：\n  `https://api.steampowered.com/ISteamUser/GetPlayerSummaries/v2/?key=$&#123;开篇申请的ApiKey&#125;&amp;steamids=$&#123;用户的SteamID&#125;`\n\n返回的数据格式：\n\"response\":&#123;  \n  \"players\":[  \n     &#123;  \n        \"steamid\":\"xxxxxxxxxxx\",\n        \"communityvisibilitystate\":1,\n        \"profilestate\":1,\n        \"personaname\":\"xxxx\",\n        \"lastlogoff\":1556305001,\n        \"profileurl\":\"https://steamcommunity.com/profiles/xxxxxxxxxxx/\",\n        \"avatar\":\"https://steamcdn-a.akamaihd.net/steamcommunity/public/images/avatars/32/xxxxxxxxxxx.jpg\",\n        \"avatarmedium\":\"https://steamcdn-a.akamaihd.net/steamcommunity/public/images/avatars/32/xxxxxxxxxxx.jpg\",\n        \"avatarfull\":\"https://steamcdn-a.akamaihd.net/steamcommunity/public/images/avatars/32/xxxxxxxxxxx.jpg\",\n     &#125;\n  ]\n&#125;\n\n至此，使用 Steam 作为网站的第三方账号登录并且获取用户的 Steam 信息就已经全部完成。\n结语 &amp; 一些小问题\n为保证数据安全性，ApiKey 应该存储在网站自己的服务器上，所有的构造链接以及校验过程都应该放在后端完成。\n\nSteam 社区登录的时候偶尔可能需要用户科学上网，一旦用户不能正常访问 Steam 的登录功能，页面要做好容错处理。\n\n\n","categories":["技术分享"],"tags":["Web","BackEnd","Steam"]},{"title":"音乐格式转换","url":"/2021/08/19/music/","content":"为什么需要我们常见的音乐格式很多，但是很多时候由于我们的一些特殊需要，必须将音乐转换成mp3格式才可以被使用。本文只是从技术的角度将ncm格式转换成mp3格式。\n注意事项请勿用作商业用途\n\n源代码# -*- coding: utf-8 -*-\nimport binascii\nimport struct\nimport base64\nimport json\nimport os\nfrom Crypto.Cipher import AES\n\ndef dump(file_path):\n    core_key = binascii.a2b_hex(\"687A4852416D736F356B496E62617857\")\n    meta_key = binascii.a2b_hex(\"2331346C6A6B5F215C5D2630553C2728\")\n    unpad = lambda s : s[0:-(s[-1] if type(s[-1]) == int else ord(s[-1]))]\n    f = open(file_path,'rb')\n    header = f.read(8)\n    assert binascii.b2a_hex(header) == b'4354454e4644414d'\n    f.seek(2, 1)\n    key_length = f.read(4)\n    key_length = struct.unpack('&lt;I', bytes(key_length))[0]\n    key_data = f.read(key_length)\n    key_data_array = bytearray(key_data)\n    for i in range (0,len(key_data_array)): key_data_array[i] ^= 0x64\n    key_data = bytes(key_data_array)\n    cryptor = AES.new(core_key, AES.MODE_ECB)\n    key_data = unpad(cryptor.decrypt(key_data))[17:]\n    key_length = len(key_data)\n    key_data = bytearray(key_data)\n    key_box = bytearray(range(256))\n    c = 0\n    last_byte = 0\n    key_offset = 0\n    for i in range(256):\n        swap = key_box[i]\n        c = (swap + last_byte + key_data[key_offset]) &amp; 0xff\n        key_offset += 1\n        if key_offset >= key_length: key_offset = 0\n        key_box[i] = key_box[c]\n        key_box[c] = swap\n        last_byte = c\n    meta_length = f.read(4)\n    meta_length = struct.unpack('&lt;I', bytes(meta_length))[0]\n    meta_data = f.read(meta_length)\n    meta_data_array = bytearray(meta_data)\n    for i in range(0,len(meta_data_array)): meta_data_array[i] ^= 0x63\n    meta_data = bytes(meta_data_array)\n    meta_data = base64.b64decode(meta_data[22:])\n    cryptor = AES.new(meta_key, AES.MODE_ECB)\n    meta_data = unpad(cryptor.decrypt(meta_data)).decode('utf-8')[6:]\n    meta_data = json.loads(meta_data)\n    crc32 = f.read(4)\n    crc32 = struct.unpack('&lt;I', bytes(crc32))[0]\n    f.seek(5, 1)\n    image_size = f.read(4)\n    image_size = struct.unpack('&lt;I', bytes(image_size))[0]\n    image_data = f.read(image_size)\n    file_name = meta_data['musicName'] + '.' + meta_data['format']\n    m = open(os.path.join(os.path.split(file_path)[0],file_name),'wb')\n    chunk = bytearray()\n    while True:\n        chunk = bytearray(f.read(0x8000))\n        chunk_length = len(chunk)\n        if not chunk:\n            break\n        for i in range(1,chunk_length+1):\n            j = i &amp; 0xff;\n            chunk[i-1] ^= key_box[(key_box[j] + key_box[(key_box[j] + j) &amp; 0xff]) &amp; 0xff]\n        m.write(chunk)\n    m.close()\n    f.close()\n\ndef file_name(file_dir):\n    for root, dirs, files in os.walk(file_dir):\n        for file in files:\n            if os.path.splitext(file)[1] == '.ncm':\n                dump(file)\n                print(file)\n\nif __name__ == '__main__':\n    import sys\n    try:\n        print(os.getcwd())\n        file_name(os.getcwd())\n    except:\n        print('fail')\n\n\n运行方式将music.py与ncm格式的音乐文件放在同一个目录下\npython music.py\n","categories":["小轮子"],"tags":["Python","音乐"]},{"title":"Hello World","url":"/2021/08/18/hello-world/","content":"关于我又开始写博客这件事起因大约两个月前，我加入了一个很有活力的创业团队。这两个月里，我作为一面的面试官参与了几次招聘，并且工作模式也从原来的瀑布式开发转成了敏捷式开发。在这个过程中，我愈发意识到良好的语言表达能力在日常生活与工作中的重要性。因此我决定开始通过写文章的方式来提升自己的语言组织能力与表述能力。\n大概会写些什么内容\n日常工作遇到的一些问题，包括但不限于：前端：Vue、Nuxt、js/ts、CSS、Webpack等后端：Node爬虫：Node、Python数据库：MySQL、TypeORM等\n\n一些阅读积累，包括但不限于： 技术型书籍阅读笔记 文学性书籍读后感\n\n造一些小轮子\n\n\n","categories":[],"tags":[]},{"title":"404","url":"/404","content":"\n\n\n  \n  [居家呆猫]-404\n  \n\n\n  \n    .container {\n      width: 100%;\n      height: 100%;\n      position: fixed;\n      top: 0;\n      left: 0;\n      display: flex;\n      flex-direction: column;\n      justify-content: flex-start;\n      align-items: center;\n    }\n    .notfind {\n      width: 80%;\n      height: 80%\n    }\n    .back {\n      margin-top: 20px;\n      font-size: 16px;\n      text-decoration:none;\n      color: #fb7299;\n    }\n  \n  \n    \n     (゜-゜)つロ返回首页\n  \n\n\n","categories":[],"tags":[]},{"title":"About Maria","url":"/about/","content":"who am I\n&#x1F5A5;&nbsp;&nbsp;喜欢尝试的 「瞎折腾」 工程师\n&#x1F43E;&nbsp;&nbsp;立志做一个【技术产品】\n\n使用过的一些技术栈\n前端：Vue\n微前端：qiankun、Single-Spa（且做过一些额外定制）\n微信小程序：Taro、uni-app、mpvue、wepy\n移动端：Flutter\n后端：NodeJs（Koa、egg、midway）\n数据库：MySQL、MongoDB\n……\n\n兴趣爱好\n音乐：摇滚、后朋、金属\n乐队：寸铁（腰）、声音碎片、高旗&amp;超载、钢心…\n\n\n阅读：加缪、里尔克、余华、赫尔曼黑塞、卡尔维诺、博尔赫斯\n电影：希区柯克、库布里克、侯麦、贾樟柯、杨德昌、毛骗团队\n技术相关：尤大、轮子哥 vczh、TK 教主\n\n最近在听的歌 \n\nIf help u如果对你有帮助，也欢迎老板的赞赏 :)\n赞赏码\n","categories":[],"tags":[]}]