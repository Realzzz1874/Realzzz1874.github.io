[{"title":"使用Steam作为第三方账号登录你的网站","url":"/2021/08/22/steam/","content":"前言  在日常网络冲浪中，很多网站要求我们注册登录的时候，我们都可以选择使用 QQ|微信|微博|Github 等作为第三方账号去登录。那么如果我的网站都是游戏相关的内容，我可不可以让用户 使用 Steam 作为第三方账号登录 呢？\n问题分析基于网页浏览器的 OpenID 验证如 OpenID 2.0（了解更多） 规范所描述，Steam 只是一个 OpenID 的提供者。在网页浏览器内，第三方网站可以使用 OpenID 来获取用户的 SteamID ，用户的 SteamID 可以用来作为第三方网站的登录凭据（登录）或者与第三方网站的既有账户绑定（注册）。\n流程描述当用户希望登录第三方网站并且将自己的账号与 Steam 账号绑定，第三方网站将用户重定向到 Steam 社区的登录授权页面，用户输入 Steam 的登录凭证后，浏览器自动重定向回第三方网站，并将一些额外的 OpenID 数据写入返回的 URL 中。这些数据通过验证之后即可解析出用户的 SteamID 。\n具体操作申请一个用来校验信息的 ApiKey到这里申请 =&gt; steamcommunity\n构造用来登录的链接参数说明：\nsteamLoginUrl: https://steamcommunity.com/openid/login\nreturnUrl: Steam社区登录之后重定向的链接，一般为登录之后的网站首页 https://xxx.com\nrealm: steam社区授权页面显示的第三方网站名称\n\n// 返回的链接\nconst url = `$&#123;steamLoginUrl&#125;?openid.ns=http://specs.openid.net/auth/2.0&amp;openid.mode=checkid_setup&amp;openid.return_to=$&#123;returnUrl&#125;&amp;openid.realm=$&#123;realm&#125;&amp;openid.identity=http://specs.openid.net/auth/2.0/identifier_select&amp;openid.claimed_id=http://specs.openid.net/auth/2.0/identifier_select`;\n\n当用户点击网页上的 Steam 登录标识的时候，浏览器将用户重定向到 url ，在用户授权之后，会回到 returnUrl 页面。\n校验Steam返回的数据当 Steam 成功授权登录返回到我们的 returnUrl 页面之后，页面链接中会带有很多额外信息：\nconst respUrl = `$&#123;returnUrl&#125;?openid.ns=http://specs.openid.net/auth/2.0&amp;openid.mode=id_res&amp;openid.op_endpoint=https://steamcommunity.com/openid/login&amp;openid.claimed_id=https://steamcommunity.com/openid/id/xxxxxxxxxxx&amp;openid.identity=https://steamcommunity.com/openid/id/xxxxxxxxxxx&amp;openid.return_to=https:/%mywebsite.com&amp;openid.response_nonce=2020-08-27T04:44:16Zs4DPZce8qc+iPCe8JgQKB0BiIDI=&amp;openid.assoc_handle=1234567890&amp;openid.signed=signed,op_endpoint,claimed_id,identity,return_to,response_nonce,assoc_handle&amp;openid.sig=W0u5DRbtHE1GG0ZKXjerUZDUGmc=`;\n\n\n具体的参数说明可参考steam官方文档\n因为返回的参数中带有用户的 SteamID 字段，为了保证信息安全，我们需要对数据进行正确性校验。定义 params = respUrl ? 后面的内容\n\n替换 params 中的 openid.mode=id_res 为 openid.mode=check_authentication\n\n构造校验链接\n const validateUrl = `https://steamcommunity.com/openid/login?$&#123;params&#125;`;\n通过 GET 请求 validateUrl 得到校验结果 得到一个 text/plain 类型的response：\n ns:http://specs.openid.net/auth/2.0\nis_valid:true\n\n is_valid:true 表明校验通过。\n\n\n通过用户的SteamID来获取用户的个人信息当校验完用户的 Steam 登录之后，我们便可以在返回的数据中获取到用户的 SteamID 。\n`openid.identity=https://steamcommunity.com/openid/id/xxxxxxxxxxx(此处则是用户的SteamID)`\n\n通过 Steam 平台开放接口，我们则可以获取到用户的 Steam 个人信息。\nGET 请求：\n  `https://api.steampowered.com/ISteamUser/GetPlayerSummaries/v2/?key=$&#123;开篇申请的ApiKey&#125;&amp;steamids=$&#123;用户的SteamID&#125;`\n\n返回的数据格式：\n\"response\":&#123;  \n  \"players\":[  \n     &#123;  \n        \"steamid\":\"xxxxxxxxxxx\",\n        \"communityvisibilitystate\":1,\n        \"profilestate\":1,\n        \"personaname\":\"xxxx\",\n        \"lastlogoff\":1556305001,\n        \"profileurl\":\"https://steamcommunity.com/profiles/xxxxxxxxxxx/\",\n        \"avatar\":\"https://steamcdn-a.akamaihd.net/steamcommunity/public/images/avatars/32/xxxxxxxxxxx.jpg\",\n        \"avatarmedium\":\"https://steamcdn-a.akamaihd.net/steamcommunity/public/images/avatars/32/xxxxxxxxxxx.jpg\",\n        \"avatarfull\":\"https://steamcdn-a.akamaihd.net/steamcommunity/public/images/avatars/32/xxxxxxxxxxx.jpg\",\n     &#125;\n  ]\n&#125;\n\n至此，使用 Steam 作为网站的第三方账号登录并且获取用户的 Steam 信息就已经全部完成。\n结语 &amp; 一些小问题\n为保证数据安全性，ApiKey 应该存储在网站自己的服务器上，所有的构造链接以及校验过程都应该放在后端完成。\n\nSteam 社区登录的时候偶尔可能需要用户科学上网，一旦用户不能正常访问 Steam 的登录功能，页面要做好容错处理。\n\n\n","categories":["技术分享"],"tags":["Steam","Web","BackEnd"]},{"title":"音乐格式转换","url":"/2021/08/19/music/","content":"为什么需要我们常见的音乐格式很多，但是很多时候由于我们的一些特殊需要，必须将音乐转换成mp3格式才可以被使用。本文只是从技术的角度将ncm格式转换成mp3格式。\n注意事项请勿用作商业用途\n\n源代码# -*- coding: utf-8 -*-\nimport binascii\nimport struct\nimport base64\nimport json\nimport os\nfrom Crypto.Cipher import AES\n\ndef dump(file_path):\n    core_key = binascii.a2b_hex(\"687A4852416D736F356B496E62617857\")\n    meta_key = binascii.a2b_hex(\"2331346C6A6B5F215C5D2630553C2728\")\n    unpad = lambda s : s[0:-(s[-1] if type(s[-1]) == int else ord(s[-1]))]\n    f = open(file_path,'rb')\n    header = f.read(8)\n    assert binascii.b2a_hex(header) == b'4354454e4644414d'\n    f.seek(2, 1)\n    key_length = f.read(4)\n    key_length = struct.unpack('&lt;I', bytes(key_length))[0]\n    key_data = f.read(key_length)\n    key_data_array = bytearray(key_data)\n    for i in range (0,len(key_data_array)): key_data_array[i] ^= 0x64\n    key_data = bytes(key_data_array)\n    cryptor = AES.new(core_key, AES.MODE_ECB)\n    key_data = unpad(cryptor.decrypt(key_data))[17:]\n    key_length = len(key_data)\n    key_data = bytearray(key_data)\n    key_box = bytearray(range(256))\n    c = 0\n    last_byte = 0\n    key_offset = 0\n    for i in range(256):\n        swap = key_box[i]\n        c = (swap + last_byte + key_data[key_offset]) &amp; 0xff\n        key_offset += 1\n        if key_offset >= key_length: key_offset = 0\n        key_box[i] = key_box[c]\n        key_box[c] = swap\n        last_byte = c\n    meta_length = f.read(4)\n    meta_length = struct.unpack('&lt;I', bytes(meta_length))[0]\n    meta_data = f.read(meta_length)\n    meta_data_array = bytearray(meta_data)\n    for i in range(0,len(meta_data_array)): meta_data_array[i] ^= 0x63\n    meta_data = bytes(meta_data_array)\n    meta_data = base64.b64decode(meta_data[22:])\n    cryptor = AES.new(meta_key, AES.MODE_ECB)\n    meta_data = unpad(cryptor.decrypt(meta_data)).decode('utf-8')[6:]\n    meta_data = json.loads(meta_data)\n    crc32 = f.read(4)\n    crc32 = struct.unpack('&lt;I', bytes(crc32))[0]\n    f.seek(5, 1)\n    image_size = f.read(4)\n    image_size = struct.unpack('&lt;I', bytes(image_size))[0]\n    image_data = f.read(image_size)\n    file_name = meta_data['musicName'] + '.' + meta_data['format']\n    m = open(os.path.join(os.path.split(file_path)[0],file_name),'wb')\n    chunk = bytearray()\n    while True:\n        chunk = bytearray(f.read(0x8000))\n        chunk_length = len(chunk)\n        if not chunk:\n            break\n        for i in range(1,chunk_length+1):\n            j = i &amp; 0xff;\n            chunk[i-1] ^= key_box[(key_box[j] + key_box[(key_box[j] + j) &amp; 0xff]) &amp; 0xff]\n        m.write(chunk)\n    m.close()\n    f.close()\n\ndef file_name(file_dir):\n    for root, dirs, files in os.walk(file_dir):\n        for file in files:\n            if os.path.splitext(file)[1] == '.ncm':\n                dump(file)\n                print(file)\n\nif __name__ == '__main__':\n    import sys\n    try:\n        print(os.getcwd())\n        file_name(os.getcwd())\n    except:\n        print('fail')\n\n\n运行方式将music.py与ncm格式的音乐文件放在同一个目录下\npython music.py\n","categories":["小轮子"],"tags":["Python","音乐"]},{"title":"Hello World","url":"/2021/08/18/hello-world/","content":"关于我又开始写博客这件事起因大约两个月前，我加入了一个很有活力的创业团队。这两个月里，我作为一面的面试官参与了几次招聘，并且工作模式也从原来的瀑布式开发转成了敏捷式开发。在这个过程中，我愈发意识到良好的语言表达能力在日常生活与工作中的重要性。因为我决定开始通过写文章的方式来提升自己的语言组织能力与表述能力。\n大概会写些什么内容\n日常工作遇到的一些问题，包括但不限于：前端：Vue、Nuxt、js/ts、CSS、Webpack等后端：Node爬虫：Node、Python数据库：MySQL、TypeORM等\n\n一些阅读积累，包括但不限于： 技术型书籍阅读笔记 文学性书籍读后感\n\n造一些小轮子\n\n\n","categories":[],"tags":[]}]